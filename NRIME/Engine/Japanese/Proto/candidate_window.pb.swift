// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocol/candidate_window.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2010-2021, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Protocol messages of candidate window to be used for mozc client/server
// communication and client/renderer communication.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Category describes the attribute of the words.
enum Mozc_Commands_Category: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case conversion = 0
  case prediction = 1
  case suggestion = 2
  case transliteration = 3
  case usage = 4

  init() {
    self = .conversion
  }

}

/// DisplayType is a hint to UI renderers describing how the words are
/// displayed.
enum Mozc_Commands_DisplayType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case main = 0
  case cascade = 1

  init() {
    self = .main
  }

}

/// CandidateAttribute indicates how the candidate was generated.
enum Mozc_Commands_CandidateAttribute: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case defaultAttribute = 0
  case userDictionary = 1
  case userHistory = 2

  /// "ふいんき"→"雰囲気"
  case spellingCorrection = 3

  /// "やんしょん"(with 12-key)→"マンション"
  case typingCorrection = 4
  case deletable = 5

  init() {
    self = .defaultAttribute
  }

}

/// General non-recursive rich text representation.
struct Mozc_Commands_RichText: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spans: [Mozc_Commands_RichText.Span] = []

  /// fallback text in plain-text format.
  var fallbackText: String {
    get {_fallbackText ?? String()}
    set {_fallbackText = newValue}
  }
  /// Returns true if `fallbackText` has been explicitly set.
  var hasFallbackText: Bool {self._fallbackText != nil}
  /// Clears the value of `fallbackText`. Subsequent reads from it will return its default value.
  mutating func clearFallbackText() {self._fallbackText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TextStyle: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Bit fields. Styles are not exclusive.
    var styles: UInt32 {
      get {_styles ?? 0}
      set {_styles = newValue}
    }
    /// Returns true if `styles` has been explicitly set.
    var hasStyles: Bool {self._styles != nil}
    /// Clears the value of `styles`. Subsequent reads from it will return its default value.
    mutating func clearStyles() {self._styles = nil}

    var fontSize: Mozc_Commands_RichText.TextStyle.FontSize {
      get {_fontSize ?? .default}
      set {_fontSize = newValue}
    }
    /// Returns true if `fontSize` has been explicitly set.
    var hasFontSize: Bool {self._fontSize != nil}
    /// Clears the value of `fontSize`. Subsequent reads from it will return its default value.
    mutating func clearFontSize() {self._fontSize = nil}

    var textColor: Mozc_Commands_RichText.TextStyle.TextColor {
      get {_textColor ?? .default}
      set {_textColor = newValue}
    }
    /// Returns true if `textColor` has been explicitly set.
    var hasTextColor: Bool {self._textColor != nil}
    /// Clears the value of `textColor`. Subsequent reads from it will return its default value.
    mutating func clearTextColor() {self._textColor = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Style: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unspecified = 0

      /// Typeface.BOLD
      case bold = 1

      /// Typeface.ITALIC
      case italic = 2

      /// UnderlineSpan
      case underline = 4

      /// StikethroughSpan
      case strikethrough = 8

      init() {
        self = .unspecified
      }

    }

    enum FontSize: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case `default` = 0
      case superscript = 1
      case `subscript` = 2
      case large = 3
      case small = 4

      init() {
        self = .default
      }

    }

    enum TextColor: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case `default` = 0
      case emphasized = 1
      case deemphasized = 2

      init() {
        self = .default
      }

    }

    init() {}

    fileprivate var _styles: UInt32? = nil
    fileprivate var _fontSize: Mozc_Commands_RichText.TextStyle.FontSize? = nil
    fileprivate var _textColor: Mozc_Commands_RichText.TextStyle.TextColor? = nil
  }

  struct Span: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String {
      get {_text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {self._text = nil}

    var textStyle: Mozc_Commands_RichText.TextStyle {
      get {_textStyle ?? Mozc_Commands_RichText.TextStyle()}
      set {_textStyle = newValue}
    }
    /// Returns true if `textStyle` has been explicitly set.
    var hasTextStyle: Bool {self._textStyle != nil}
    /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
    mutating func clearTextStyle() {self._textStyle = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _text: String? = nil
    fileprivate var _textStyle: Mozc_Commands_RichText.TextStyle? = nil
  }

  init() {}

  fileprivate var _fallbackText: String? = nil
}

/// Annotation against a candidate.
struct Mozc_Commands_Annotation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Annotation prepended to the value.
  var prefix: String {
    get {_prefix ?? String()}
    set {_prefix = newValue}
  }
  /// Returns true if `prefix` has been explicitly set.
  var hasPrefix: Bool {self._prefix != nil}
  /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
  mutating func clearPrefix() {self._prefix = nil}

  /// Annotation appended to the value.
  var suffix: String {
    get {_suffix ?? String()}
    set {_suffix = newValue}
  }
  /// Returns true if `suffix` has been explicitly set.
  var hasSuffix: Bool {self._suffix != nil}
  /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
  mutating func clearSuffix() {self._suffix = nil}

  /// Type of the candidate such as [HALF][KATAKANA], [GREEK],
  /// [Black square], etc...
  var description_p: String {
    get {_description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// Shortcut key to select this candidate.
  var shortcut: String {
    get {_shortcut ?? String()}
    set {_shortcut = newValue}
  }
  /// Returns true if `shortcut` has been explicitly set.
  var hasShortcut: Bool {self._shortcut != nil}
  /// Clears the value of `shortcut`. Subsequent reads from it will return its default value.
  mutating func clearShortcut() {self._shortcut = nil}

  /// Set to true if this candidate can be deleted from history.
  var deletable: Bool {
    get {_deletable ?? false}
    set {_deletable = newValue}
  }
  /// Returns true if `deletable` has been explicitly set.
  var hasDeletable: Bool {self._deletable != nil}
  /// Clears the value of `deletable`. Subsequent reads from it will return its default value.
  mutating func clearDeletable() {self._deletable = nil}

  /// Description of the candidate for A11y support.
  /// One of the example usage of this field is android:contentDescription in
  /// Android.
  var a11YDescription: String {
    get {_a11YDescription ?? String()}
    set {_a11YDescription = newValue}
  }
  /// Returns true if `a11YDescription` has been explicitly set.
  var hasA11YDescription: Bool {self._a11YDescription != nil}
  /// Clears the value of `a11YDescription`. Subsequent reads from it will return its default value.
  mutating func clearA11YDescription() {self._a11YDescription = nil}

  /// Actual value to be displayed. Uses it to encode meta information
  /// in the value. e.g., puts "_" to clarify the unrecognizable white spaces.
  var displayValue: String {
    get {_displayValue ?? String()}
    set {_displayValue = newValue}
  }
  /// Returns true if `displayValue` has been explicitly set.
  var hasDisplayValue: Bool {self._displayValue != nil}
  /// Clears the value of `displayValue`. Subsequent reads from it will return its default value.
  mutating func clearDisplayValue() {self._displayValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _prefix: String? = nil
  fileprivate var _suffix: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _shortcut: String? = nil
  fileprivate var _deletable: Bool? = nil
  fileprivate var _a11YDescription: String? = nil
  fileprivate var _displayValue: String? = nil
}

/// Additional information to a candidate word.  This message is
/// used for describing a word usage for instance.
struct Mozc_Commands_Information: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique number specifying the information.
  var id: Int32 {
    get {_id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// Title string of the information.  For usage, this value is
  /// probably equal to Candidate::value or its canonicalized value.
  var title: String {
    get {_title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  /// The content of the information.  For usage, this value actually
  /// describes how to use the word.
  var description_p: String {
    get {_description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// The IDs of candidates which connect with the information.
  var candidateID: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _title: String? = nil
  fileprivate var _description_p: String? = nil
}

struct Mozc_Commands_InformationList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var focusedIndex: UInt32 {
    get {_focusedIndex ?? 0}
    set {_focusedIndex = newValue}
  }
  /// Returns true if `focusedIndex` has been explicitly set.
  var hasFocusedIndex: Bool {self._focusedIndex != nil}
  /// Clears the value of `focusedIndex`. Subsequent reads from it will return its default value.
  mutating func clearFocusedIndex() {self._focusedIndex = nil}

  var information: [Mozc_Commands_Information] = []

  /// Category of the infolist.
  var category: Mozc_Commands_Category {
    get {_category ?? .conversion}
    set {_category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  var hasCategory: Bool {self._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  mutating func clearCategory() {self._category = nil}

  /// Information to be used for rendering.
  var displayType: Mozc_Commands_DisplayType {
    get {_displayType ?? .cascade}
    set {_displayType = newValue}
  }
  /// Returns true if `displayType` has been explicitly set.
  var hasDisplayType: Bool {self._displayType != nil}
  /// Clears the value of `displayType`. Subsequent reads from it will return its default value.
  mutating func clearDisplayType() {self._displayType = nil}

  /// How long rendere needs to wait before the infolist is displayed.
  /// the default setting is 500 msec.
  var delay: UInt32 {
    get {_delay ?? 500}
    set {_delay = newValue}
  }
  /// Returns true if `delay` has been explicitly set.
  var hasDelay: Bool {self._delay != nil}
  /// Clears the value of `delay`. Subsequent reads from it will return its default value.
  mutating func clearDelay() {self._delay = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _focusedIndex: UInt32? = nil
  fileprivate var _category: Mozc_Commands_Category? = nil
  fileprivate var _displayType: Mozc_Commands_DisplayType? = nil
  fileprivate var _delay: UInt32? = nil
}

/// Message representing the footer part of the candidate window.
struct Mozc_Commands_Footer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message shown like a status bar.
  var label: String {
    get {_label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  /// Whether index (e.g. 10/120) is visible or not.
  var indexVisible: Bool {
    get {_indexVisible ?? false}
    set {_indexVisible = newValue}
  }
  /// Returns true if `indexVisible` has been explicitly set.
  var hasIndexVisible: Bool {self._indexVisible != nil}
  /// Clears the value of `indexVisible`. Subsequent reads from it will return its default value.
  mutating func clearIndexVisible() {self._indexVisible = nil}

  /// Whether the logo image is visible or not.
  var logoVisible: Bool {
    get {_logoVisible ?? false}
    set {_logoVisible = newValue}
  }
  /// Returns true if `logoVisible` has been explicitly set.
  var hasLogoVisible: Bool {self._logoVisible != nil}
  /// Clears the value of `logoVisible`. Subsequent reads from it will return its default value.
  mutating func clearLogoVisible() {self._logoVisible = nil}

  /// Message modestly shown.  It is used for displaying the version on
  /// dev-channel now.
  var subLabel: String {
    get {_subLabel ?? String()}
    set {_subLabel = newValue}
  }
  /// Returns true if `subLabel` has been explicitly set.
  var hasSubLabel: Bool {self._subLabel != nil}
  /// Clears the value of `subLabel`. Subsequent reads from it will return its default value.
  mutating func clearSubLabel() {self._subLabel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _label: String? = nil
  fileprivate var _indexVisible: Bool? = nil
  fileprivate var _logoVisible: Bool? = nil
  fileprivate var _subLabel: String? = nil
}

struct Mozc_Commands_CandidateWord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique number specifying the candidate. This may be a negative value.
  var id: Int32 {
    get {_id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// The first index should be zero and index numbers should increase by one.
  var index: UInt32 {
    get {_index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  /// Reading of the value.  The value is only used when the key is
  /// different from the input composition (e.g. suggestion/prediction).
  var key: String {
    get {_key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// Converted value.  (e.g. Kanji value).
  var value: String {
    get {_value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var annotation: Mozc_Commands_Annotation {
    get {_annotation ?? Mozc_Commands_Annotation()}
    set {_annotation = newValue}
  }
  /// Returns true if `annotation` has been explicitly set.
  var hasAnnotation: Bool {self._annotation != nil}
  /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
  mutating func clearAnnotation() {self._annotation = nil}

  /// Attributes of this candidate. Can set multiple attributes.
  var attributes: [Mozc_Commands_CandidateAttribute] = []

  /// The number of segments for logging.
  /// If the candidate is "今日は|晴れ", the number of segments is 2.
  var numSegmentsInCandidate: Int32 {
    get {_numSegmentsInCandidate ?? 0}
    set {_numSegmentsInCandidate = newValue}
  }
  /// Returns true if `numSegmentsInCandidate` has been explicitly set.
  var hasNumSegmentsInCandidate: Bool {self._numSegmentsInCandidate != nil}
  /// Clears the value of `numSegmentsInCandidate`. Subsequent reads from it will return its default value.
  mutating func clearNumSegmentsInCandidate() {self._numSegmentsInCandidate = nil}

  /// Debug log for this candidate word.
  var log: String {
    get {_log ?? String()}
    set {_log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {self._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {self._log = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Int32? = nil
  fileprivate var _index: UInt32? = nil
  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
  fileprivate var _annotation: Mozc_Commands_Annotation? = nil
  fileprivate var _numSegmentsInCandidate: Int32? = nil
  fileprivate var _log: String? = nil
}

struct Mozc_Commands_CandidateList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This value represents the focused position of the next
  /// |candidates|.  If the |candidates| is a part of the whole
  /// candidate words (as a result of paging), this value indicates the
  /// position from the beginning of that part.  (ex. where
  /// |candidates| contains 10th to 18th candidates, focused_index=0
  /// means the 10th candidate, but not 1st candidate.
  ///
  /// The existense of |focused_index| does not represents whether this
  /// candidate list is a 'suggestion' or not.  |category| represents
  /// it.
  var focusedIndex: UInt32 {
    get {_focusedIndex ?? 0}
    set {_focusedIndex = newValue}
  }
  /// Returns true if `focusedIndex` has been explicitly set.
  var hasFocusedIndex: Bool {self._focusedIndex != nil}
  /// Clears the value of `focusedIndex`. Subsequent reads from it will return its default value.
  mutating func clearFocusedIndex() {self._focusedIndex = nil}

  var candidates: [Mozc_Commands_CandidateWord] = []

  /// Category of the candidates.
  var category: Mozc_Commands_Category {
    get {_category ?? .conversion}
    set {_category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  var hasCategory: Bool {self._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  mutating func clearCategory() {self._category = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _focusedIndex: UInt32? = nil
  fileprivate var _category: Mozc_Commands_Category? = nil
}

struct Mozc_Commands_CandidateWindow: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO(komatsu): Use CandidateList.
  /// When has_focused_index() is true, this message contains predicted and
  /// normally converted candidates. Otherwise, when the field is not set,
  /// this message contains a 'suggestion'.
  var focusedIndex: UInt32 {
    get {_storage._focusedIndex ?? 0}
    set {_uniqueStorage()._focusedIndex = newValue}
  }
  /// Returns true if `focusedIndex` has been explicitly set.
  var hasFocusedIndex: Bool {_storage._focusedIndex != nil}
  /// Clears the value of `focusedIndex`. Subsequent reads from it will return its default value.
  mutating func clearFocusedIndex() {_uniqueStorage()._focusedIndex = nil}

  /// The size of the total candidates in this candidate list.  The
  /// value does not include the size of subcandidate lists.  Note, the
  /// next repeated-Candidate=3 may not contain all candidates.
  /// all_candidates contains the values of subcandidate lists.
  var size: UInt32 {
    get {_storage._size ?? 0}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {_storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {_uniqueStorage()._size = nil}

  var candidate: [Mozc_Commands_CandidateWindow.Candidate] {
    get {_storage._candidate}
    set {_uniqueStorage()._candidate = newValue}
  }

  /// The position on the composition in character counted by Util::CharsLen.
  /// The number represents the left edge of the candidate window.  For example,
  /// if the composition is "あいう" and the cursor is the position is between
  /// "あ" and "い" (e.g. "あ|いう"), the number should be 1.
  /// Note, Util::CharsLen does not take care of IVS or combining character
  /// so much.  Thus CharsLen's behavior on those characters might be changed.
  var position: UInt32 {
    get {_storage._position ?? 0}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {_storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {_uniqueStorage()._position = nil}

  /// Nested candidates aka cascading window.
  var subCandidateWindow: Mozc_Commands_CandidateWindow {
    get {_storage._subCandidateWindow ?? Mozc_Commands_CandidateWindow()}
    set {_uniqueStorage()._subCandidateWindow = newValue}
  }
  /// Returns true if `subCandidateWindow` has been explicitly set.
  var hasSubCandidateWindow: Bool {_storage._subCandidateWindow != nil}
  /// Clears the value of `subCandidateWindow`. Subsequent reads from it will return its default value.
  mutating func clearSubCandidateWindow() {_uniqueStorage()._subCandidateWindow = nil}

  /// Usages of candidates.
  var usages: Mozc_Commands_InformationList {
    get {_storage._usages ?? Mozc_Commands_InformationList()}
    set {_uniqueStorage()._usages = newValue}
  }
  /// Returns true if `usages` has been explicitly set.
  var hasUsages: Bool {_storage._usages != nil}
  /// Clears the value of `usages`. Subsequent reads from it will return its default value.
  mutating func clearUsages() {_uniqueStorage()._usages = nil}

  /// TODO(komatsu): Use CandidateList.
  /// Category of the candidates
  var category: Mozc_Commands_Category {
    get {_storage._category ?? .conversion}
    set {_uniqueStorage()._category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  var hasCategory: Bool {_storage._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  mutating func clearCategory() {_uniqueStorage()._category = nil}

  /// Information to be used for rendering.
  var displayType: Mozc_Commands_DisplayType {
    get {_storage._displayType ?? .main}
    set {_uniqueStorage()._displayType = newValue}
  }
  /// Returns true if `displayType` has been explicitly set.
  var hasDisplayType: Bool {_storage._displayType != nil}
  /// Clears the value of `displayType`. Subsequent reads from it will return its default value.
  mutating func clearDisplayType() {_uniqueStorage()._displayType = nil}

  /// Footer of the GUI window.
  var footer: Mozc_Commands_Footer {
    get {_storage._footer ?? Mozc_Commands_Footer()}
    set {_uniqueStorage()._footer = newValue}
  }
  /// Returns true if `footer` has been explicitly set.
  var hasFooter: Bool {_storage._footer != nil}
  /// Clears the value of `footer`. Subsequent reads from it will return its default value.
  mutating func clearFooter() {_uniqueStorage()._footer = nil}

  var direction: Mozc_Commands_CandidateWindow.Direction {
    get {_storage._direction ?? .vertical}
    set {_uniqueStorage()._direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {_storage._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {_uniqueStorage()._direction = nil}

  /// The number of candidates per page.
  var pageSize: UInt32 {
    get {_storage._pageSize ?? 9}
    set {_uniqueStorage()._pageSize = newValue}
  }
  /// Returns true if `pageSize` has been explicitly set.
  var hasPageSize: Bool {_storage._pageSize != nil}
  /// Clears the value of `pageSize`. Subsequent reads from it will return its default value.
  mutating func clearPageSize() {_uniqueStorage()._pageSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The direction of candidates in the window.  This is just a
  /// suggestion from the server and client does not have to follow.
  enum Direction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case vertical = 0
    case horizontal = 1

    init() {
      self = .vertical
    }

  }

  /// TODO(komatsu): Use CandidateList.
  struct Candidate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The first index should be zero and index numbers should increase by one.
    var index: UInt32 {
      get {_index ?? 0}
      set {_index = newValue}
    }
    /// Returns true if `index` has been explicitly set.
    var hasIndex: Bool {self._index != nil}
    /// Clears the value of `index`. Subsequent reads from it will return its default value.
    mutating func clearIndex() {self._index = nil}

    var value: String {
      get {_value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    /// Unique number specifing the candidate.
    var id: Int32 {
      get {_id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var annotation: Mozc_Commands_Annotation {
      get {_annotation ?? Mozc_Commands_Annotation()}
      set {_annotation = newValue}
    }
    /// Returns true if `annotation` has been explicitly set.
    var hasAnnotation: Bool {self._annotation != nil}
    /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
    mutating func clearAnnotation() {self._annotation = nil}

    var informationID: Int32 {
      get {_informationID ?? 0}
      set {_informationID = newValue}
    }
    /// Returns true if `informationID` has been explicitly set.
    var hasInformationID: Bool {self._informationID != nil}
    /// Clears the value of `informationID`. Subsequent reads from it will return its default value.
    mutating func clearInformationID() {self._informationID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _index: UInt32? = nil
    fileprivate var _value: String? = nil
    fileprivate var _id: Int32? = nil
    fileprivate var _annotation: Mozc_Commands_Annotation? = nil
    fileprivate var _informationID: Int32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mozc.commands"

extension Mozc_Commands_Category: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONVERSION\0\u{1}PREDICTION\0\u{1}SUGGESTION\0\u{1}TRANSLITERATION\0\u{1}USAGE\0")
}

extension Mozc_Commands_DisplayType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MAIN\0\u{1}CASCADE\0")
}

extension Mozc_Commands_CandidateAttribute: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT_ATTRIBUTE\0\u{1}USER_DICTIONARY\0\u{1}USER_HISTORY\0\u{1}SPELLING_CORRECTION\0\u{1}TYPING_CORRECTION\0\u{1}DELETABLE\0")
}

extension Mozc_Commands_RichText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RichText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spans\0\u{3}fallback_text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fallbackText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 1)
    }
    try { if let v = self._fallbackText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_RichText, rhs: Mozc_Commands_RichText) -> Bool {
    if lhs.spans != rhs.spans {return false}
    if lhs._fallbackText != rhs._fallbackText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_RichText.TextStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_RichText.protoMessageName + ".TextStyle"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}styles\0\u{3}font_size\0\u{3}text_color\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._styles) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._fontSize) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._textColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._styles {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fontSize {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textColor {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_RichText.TextStyle, rhs: Mozc_Commands_RichText.TextStyle) -> Bool {
    if lhs._styles != rhs._styles {return false}
    if lhs._fontSize != rhs._fontSize {return false}
    if lhs._textColor != rhs._textColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_RichText.TextStyle.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STYLE_UNSPECIFIED\0\u{1}STYLE_BOLD\0\u{1}STYLE_ITALIC\0\u{2}\u{2}STYLE_UNDERLINE\0\u{2}\u{4}STYLE_STRIKETHROUGH\0")
}

extension Mozc_Commands_RichText.TextStyle.FontSize: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FONT_SIZE_DEFAULT\0\u{1}FONT_SIZE_SUPERSCRIPT\0\u{1}FONT_SIZE_SUBSCRIPT\0\u{1}FONT_SIZE_LARGE\0\u{1}FONT_SIZE_SMALL\0")
}

extension Mozc_Commands_RichText.TextStyle.TextColor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TEXT_COLOR_DEFAULT\0\u{1}TEXT_COLOR_EMPHASIZED\0\u{1}TEXT_COLOR_DEEMPHASIZED\0")
}

extension Mozc_Commands_RichText.Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_RichText.protoMessageName + ".Span"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}text_style\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._textStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_RichText.Span, rhs: Mozc_Commands_RichText.Span) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._textStyle != rhs._textStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Annotation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}prefix\0\u{1}suffix\0\u{1}description\0\u{1}shortcut\0\u{1}deletable\0\u{3}a11y_description\0\u{3}display_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._shortcut) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._deletable) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._a11YDescription) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._displayValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._shortcut {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deletable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._a11YDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._displayValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Annotation, rhs: Mozc_Commands_Annotation) -> Bool {
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._shortcut != rhs._shortcut {return false}
    if lhs._deletable != rhs._deletable {return false}
    if lhs._a11YDescription != rhs._a11YDescription {return false}
    if lhs._displayValue != rhs._displayValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Information: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Information"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}description\0\u{3}candidate_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.candidateID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.candidateID.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.candidateID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Information, rhs: Mozc_Commands_Information) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._title != rhs._title {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.candidateID != rhs.candidateID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_InformationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InformationList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}focused_index\0\u{1}information\0\u{1}category\0\u{3}display_type\0\u{1}delay\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._focusedIndex) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.information) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._category) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._displayType) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._delay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._focusedIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.information.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.information, fieldNumber: 2)
    }
    try { if let v = self._category {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._displayType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._delay {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_InformationList, rhs: Mozc_Commands_InformationList) -> Bool {
    if lhs._focusedIndex != rhs._focusedIndex {return false}
    if lhs.information != rhs.information {return false}
    if lhs._category != rhs._category {return false}
    if lhs._displayType != rhs._displayType {return false}
    if lhs._delay != rhs._delay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Footer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Footer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}label\0\u{3}index_visible\0\u{3}logo_visible\0\u{3}sub_label\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._indexVisible) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._logoVisible) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._subLabel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._indexVisible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._logoVisible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Footer, rhs: Mozc_Commands_Footer) -> Bool {
    if lhs._label != rhs._label {return false}
    if lhs._indexVisible != rhs._indexVisible {return false}
    if lhs._logoVisible != rhs._logoVisible {return false}
    if lhs._subLabel != rhs._subLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_CandidateWord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CandidateWord"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}index\0\u{1}key\0\u{1}value\0\u{1}annotation\0\u{1}attributes\0\u{3}num_segments_in_candidate\0\u{2}]\u{1}log\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.attributes) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._numSegmentsInCandidate) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self._log) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.attributes, fieldNumber: 6)
    }
    try { if let v = self._numSegmentsInCandidate {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._log {
      try visitor.visitSingularStringField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_CandidateWord, rhs: Mozc_Commands_CandidateWord) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._index != rhs._index {return false}
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs._numSegmentsInCandidate != rhs._numSegmentsInCandidate {return false}
    if lhs._log != rhs._log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_CandidateList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CandidateList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}focused_index\0\u{1}candidates\0\u{1}category\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._focusedIndex) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.candidates) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._category) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._focusedIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.candidates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.candidates, fieldNumber: 2)
    }
    try { if let v = self._category {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_CandidateList, rhs: Mozc_Commands_CandidateList) -> Bool {
    if lhs._focusedIndex != rhs._focusedIndex {return false}
    if lhs.candidates != rhs.candidates {return false}
    if lhs._category != rhs._category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_CandidateWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CandidateWindow"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}focused_index\0\u{1}size\0\u{7}Candidate\0\u{2}\u{3}position\0\u{4}\u{2}sub_candidate_window\0\u{2}\u{2}usages\0\u{1}category\0\u{3}display_type\0\u{1}footer\0\u{1}direction\0\u{4}\u{4}page_size\0\u{b}composition_rectangle\0\u{b}caret_rectangle\0\u{b}window_location\0\u{c}\u{f}\u{1}\u{c}\u{10}\u{1}\u{c}\u{11}\u{1}")

  fileprivate class _StorageClass {
    var _focusedIndex: UInt32? = nil
    var _size: UInt32? = nil
    var _candidate: [Mozc_Commands_CandidateWindow.Candidate] = []
    var _position: UInt32? = nil
    var _subCandidateWindow: Mozc_Commands_CandidateWindow? = nil
    var _usages: Mozc_Commands_InformationList? = nil
    var _category: Mozc_Commands_Category? = nil
    var _displayType: Mozc_Commands_DisplayType? = nil
    var _footer: Mozc_Commands_Footer? = nil
    var _direction: Mozc_Commands_CandidateWindow.Direction? = nil
    var _pageSize: UInt32? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _focusedIndex = source._focusedIndex
      _size = source._size
      _candidate = source._candidate
      _position = source._position
      _subCandidateWindow = source._subCandidateWindow
      _usages = source._usages
      _category = source._category
      _displayType = source._displayType
      _footer = source._footer
      _direction = source._direction
      _pageSize = source._pageSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._size == nil {return false}
      if _storage._position == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._candidate) {return false}
      if let v = _storage._subCandidateWindow, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._focusedIndex) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._size) }()
        case 3: try { try decoder.decodeRepeatedGroupField(value: &_storage._candidate) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._position) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._subCandidateWindow) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._usages) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._displayType) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._footer) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._direction) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._pageSize) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._focusedIndex {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._size {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      if !_storage._candidate.isEmpty {
        try visitor.visitRepeatedGroupField(value: _storage._candidate, fieldNumber: 3)
      }
      try { if let v = _storage._position {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._subCandidateWindow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._usages {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._category {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._displayType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._footer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._direction {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._pageSize {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_CandidateWindow, rhs: Mozc_Commands_CandidateWindow) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._focusedIndex != rhs_storage._focusedIndex {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._candidate != rhs_storage._candidate {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._subCandidateWindow != rhs_storage._subCandidateWindow {return false}
        if _storage._usages != rhs_storage._usages {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._displayType != rhs_storage._displayType {return false}
        if _storage._footer != rhs_storage._footer {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._pageSize != rhs_storage._pageSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_CandidateWindow.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VERTICAL\0\u{1}HORIZONTAL\0")
}

extension Mozc_Commands_CandidateWindow.Candidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_CandidateWindow.protoMessageName + ".Candidate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{4}index\0\u{1}value\0\u{2}\u{2}annotation\0\u{2}\u{2}id\0\u{3}information_id\0")

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._value == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._annotation) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._informationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._annotation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._informationID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_CandidateWindow.Candidate, rhs: Mozc_Commands_CandidateWindow.Candidate) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._value != rhs._value {return false}
    if lhs._id != rhs._id {return false}
    if lhs._annotation != rhs._annotation {return false}
    if lhs._informationID != rhs._informationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
