// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocol/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2010-2021, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/// Protocol messages to be used for mozc configuration.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///////////////////////////////////////////////////////////////
///
/// General config (1-9)
struct Mozc_Config_GeneralConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// config version, corresponding to the suffix of config file
  var configVersion: UInt32 {
    get {_configVersion ?? 0}
    set {_configVersion = newValue}
  }
  /// Returns true if `configVersion` has been explicitly set.
  var hasConfigVersion: Bool {self._configVersion != nil}
  /// Clears the value of `configVersion`. Subsequent reads from it will return its default value.
  mutating func clearConfigVersion() {self._configVersion = nil}

  /// The product version that wrote this config
  var lastModifiedProductVersion: String {
    get {_lastModifiedProductVersion ?? "0.0.0.0"}
    set {_lastModifiedProductVersion = newValue}
  }
  /// Returns true if `lastModifiedProductVersion` has been explicitly set.
  var hasLastModifiedProductVersion: Bool {self._lastModifiedProductVersion != nil}
  /// Clears the value of `lastModifiedProductVersion`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedProductVersion() {self._lastModifiedProductVersion = nil}

  /// last modified time in UTC second
  var lastModifiedTime: UInt64 {
    get {_lastModifiedTime ?? 0}
    set {_lastModifiedTime = newValue}
  }
  /// Returns true if `lastModifiedTime` has been explicitly set.
  var hasLastModifiedTime: Bool {self._lastModifiedTime != nil}
  /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedTime() {self._lastModifiedTime = nil}

  /// These fields are not used now
  /// platform of machine that wrote this config
  var platform: String {
    get {_platform ?? String()}
    set {_platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  var hasPlatform: Bool {self._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  mutating func clearPlatform() {self._platform = nil}

  /// UI locale of machine that wrote this config
  var uiLocale: String {
    get {_uiLocale ?? String()}
    set {_uiLocale = newValue}
  }
  /// Returns true if `uiLocale` has been explicitly set.
  var hasUiLocale: Bool {self._uiLocale != nil}
  /// Clears the value of `uiLocale`. Subsequent reads from it will return its default value.
  mutating func clearUiLocale() {self._uiLocale = nil}

  /// Whether to upload usage stats
  /// This flag is used only for Android.
  var uploadUsageStats: Bool {
    get {_uploadUsageStats ?? false}
    set {_uploadUsageStats = newValue}
  }
  /// Returns true if `uploadUsageStats` has been explicitly set.
  var hasUploadUsageStats: Bool {self._uploadUsageStats != nil}
  /// Clears the value of `uploadUsageStats`. Subsequent reads from it will return its default value.
  mutating func clearUploadUsageStats() {self._uploadUsageStats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configVersion: UInt32? = nil
  fileprivate var _lastModifiedProductVersion: String? = nil
  fileprivate var _lastModifiedTime: UInt64? = nil
  fileprivate var _platform: String? = nil
  fileprivate var _uiLocale: String? = nil
  fileprivate var _uploadUsageStats: Bool? = nil
}

struct Mozc_Config_Config: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// General config and logging/debugging:
  /// We won't use 2-9 and 20-39 ids anymore for historical reasons.
  var generalConfig: Mozc_Config_GeneralConfig {
    get {_storage._generalConfig ?? Mozc_Config_GeneralConfig()}
    set {_uniqueStorage()._generalConfig = newValue}
  }
  /// Returns true if `generalConfig` has been explicitly set.
  var hasGeneralConfig: Bool {_storage._generalConfig != nil}
  /// Clears the value of `generalConfig`. Subsequent reads from it will return its default value.
  mutating func clearGeneralConfig() {_uniqueStorage()._generalConfig = nil}

  /// set verbose level of logging library (FLAGS_v)
  var verboseLevel: Int32 {
    get {_storage._verboseLevel ?? 0}
    set {_uniqueStorage()._verboseLevel = newValue}
  }
  /// Returns true if `verboseLevel` has been explicitly set.
  var hasVerboseLevel: Bool {_storage._verboseLevel != nil}
  /// Clears the value of `verboseLevel`. Subsequent reads from it will return its default value.
  mutating func clearVerboseLevel() {_uniqueStorage()._verboseLevel = nil}

  /// Incognito mode:
  /// Disable all mutable operation if incognito_mode is true
  /// Clients needs to check ConversionRequest::incognito_mode() instead
  /// of Config::incognito_mode(), as the incoginto mode can also set
  /// via Options.
  var incognitoMode: Bool {
    get {_storage._incognitoMode ?? false}
    set {_uniqueStorage()._incognitoMode = newValue}
  }
  /// Returns true if `incognitoMode` has been explicitly set.
  var hasIncognitoMode: Bool {_storage._incognitoMode != nil}
  /// Clears the value of `incognitoMode`. Subsequent reads from it will return its default value.
  mutating func clearIncognitoMode() {_uniqueStorage()._incognitoMode = nil}

  /// whether to show the set default dialog on startup
  var checkDefault: Bool {
    get {_storage._checkDefault ?? true}
    set {_uniqueStorage()._checkDefault = newValue}
  }
  /// Returns true if `checkDefault` has been explicitly set.
  var hasCheckDefault: Bool {_storage._checkDefault != nil}
  /// Clears the value of `checkDefault`. Subsequent reads from it will return its default value.
  mutating func clearCheckDefault() {_uniqueStorage()._checkDefault = nil}

  /// Presentation mode:
  /// disable all suggestion temporally.
  var presentationMode: Bool {
    get {_storage._presentationMode ?? false}
    set {_uniqueStorage()._presentationMode = newValue}
  }
  /// Returns true if `presentationMode` has been explicitly set.
  var hasPresentationMode: Bool {_storage._presentationMode != nil}
  /// Clears the value of `presentationMode`. Subsequent reads from it will return its default value.
  mutating func clearPresentationMode() {_uniqueStorage()._presentationMode = nil}

  /// Roman/Kana
  var preeditMethod: Mozc_Config_Config.PreeditMethod {
    get {_storage._preeditMethod ?? .roman}
    set {_uniqueStorage()._preeditMethod = newValue}
  }
  /// Returns true if `preeditMethod` has been explicitly set.
  var hasPreeditMethod: Bool {_storage._preeditMethod != nil}
  /// Clears the value of `preeditMethod`. Subsequent reads from it will return its default value.
  mutating func clearPreeditMethod() {_uniqueStorage()._preeditMethod = nil}

  var sessionKeymap: Mozc_Config_Config.SessionKeymap {
    get {_storage._sessionKeymap ?? .none}
    set {_uniqueStorage()._sessionKeymap = newValue}
  }
  /// Returns true if `sessionKeymap` has been explicitly set.
  var hasSessionKeymap: Bool {_storage._sessionKeymap != nil}
  /// Clears the value of `sessionKeymap`. Subsequent reads from it will return its default value.
  mutating func clearSessionKeymap() {_uniqueStorage()._sessionKeymap = nil}

  /// custom keymap
  /// TODO(taku): replace it with repeated field
  var customKeymapTable: Data {
    get {_storage._customKeymapTable ?? Data()}
    set {_uniqueStorage()._customKeymapTable = newValue}
  }
  /// Returns true if `customKeymapTable` has been explicitly set.
  var hasCustomKeymapTable: Bool {_storage._customKeymapTable != nil}
  /// Clears the value of `customKeymapTable`. Subsequent reads from it will return its default value.
  mutating func clearCustomKeymapTable() {_uniqueStorage()._customKeymapTable = nil}

  /// custom roman table
  var customRomanTable: Data {
    get {_storage._customRomanTable ?? Data()}
    set {_uniqueStorage()._customRomanTable = newValue}
  }
  /// Returns true if `customRomanTable` has been explicitly set.
  var hasCustomRomanTable: Bool {_storage._customRomanTable != nil}
  /// Clears the value of `customRomanTable`. Subsequent reads from it will return its default value.
  mutating func clearCustomRomanTable() {_uniqueStorage()._customRomanTable = nil}

  var punctuationMethod: Mozc_Config_Config.PunctuationMethod {
    get {_storage._punctuationMethod ?? .toutenKuten}
    set {_uniqueStorage()._punctuationMethod = newValue}
  }
  /// Returns true if `punctuationMethod` has been explicitly set.
  var hasPunctuationMethod: Bool {_storage._punctuationMethod != nil}
  /// Clears the value of `punctuationMethod`. Subsequent reads from it will return its default value.
  mutating func clearPunctuationMethod() {_uniqueStorage()._punctuationMethod = nil}

  var symbolMethod: Mozc_Config_Config.SymbolMethod {
    get {_storage._symbolMethod ?? .cornerBracketMiddleDot}
    set {_uniqueStorage()._symbolMethod = newValue}
  }
  /// Returns true if `symbolMethod` has been explicitly set.
  var hasSymbolMethod: Bool {_storage._symbolMethod != nil}
  /// Clears the value of `symbolMethod`. Subsequent reads from it will return its default value.
  mutating func clearSymbolMethod() {_uniqueStorage()._symbolMethod = nil}

  var spaceCharacterForm: Mozc_Config_Config.FundamentalCharacterForm {
    get {_storage._spaceCharacterForm ?? .fundamentalInputMode}
    set {_uniqueStorage()._spaceCharacterForm = newValue}
  }
  /// Returns true if `spaceCharacterForm` has been explicitly set.
  var hasSpaceCharacterForm: Bool {_storage._spaceCharacterForm != nil}
  /// Clears the value of `spaceCharacterForm`. Subsequent reads from it will return its default value.
  mutating func clearSpaceCharacterForm() {_uniqueStorage()._spaceCharacterForm = nil}

  /// If this flag is true, Mozc toggles preedit method with some predefined
  /// key events when IME is turned on.  Otherwise, Mozc ignores such kind of
  /// key events so that their preferred can be preserved even when the toggle
  /// key is pressed by accident.
  /// As for Mozc, only Windows client supports such kind of toggle so this flag
  /// is currently valid only on Windows.
  ///
  /// Background:
  ///   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
  ///   keyboard to toggle the preedit method between Roman and Kana style and
  ///   this behavior was finally adopted into JIS X 4064:2002 as a basic
  ///   functionality which is expected to support by a Japanese Input Method.
  ///   However, people who are not aware of this functionality have been
  ///   puzzled because the default key stroke is likely to be pressed
  ///   by accident.
  var useKeyboardToChangePreeditMethod: Bool {
    get {_storage._useKeyboardToChangePreeditMethod ?? false}
    set {_uniqueStorage()._useKeyboardToChangePreeditMethod = newValue}
  }
  /// Returns true if `useKeyboardToChangePreeditMethod` has been explicitly set.
  var hasUseKeyboardToChangePreeditMethod: Bool {_storage._useKeyboardToChangePreeditMethod != nil}
  /// Clears the value of `useKeyboardToChangePreeditMethod`. Subsequent reads from it will return its default value.
  mutating func clearUseKeyboardToChangePreeditMethod() {_uniqueStorage()._useKeyboardToChangePreeditMethod = nil}

  var historyLearningLevel: Mozc_Config_Config.HistoryLearningLevel {
    get {_storage._historyLearningLevel ?? .defaultHistory}
    set {_uniqueStorage()._historyLearningLevel = newValue}
  }
  /// Returns true if `historyLearningLevel` has been explicitly set.
  var hasHistoryLearningLevel: Bool {_storage._historyLearningLevel != nil}
  /// Clears the value of `historyLearningLevel`. Subsequent reads from it will return its default value.
  mutating func clearHistoryLearningLevel() {_uniqueStorage()._historyLearningLevel = nil}

  var selectionShortcut: Mozc_Config_Config.SelectionShortcut {
    get {_storage._selectionShortcut ?? .shortcut123456789}
    set {_uniqueStorage()._selectionShortcut = newValue}
  }
  /// Returns true if `selectionShortcut` has been explicitly set.
  var hasSelectionShortcut: Bool {_storage._selectionShortcut != nil}
  /// Clears the value of `selectionShortcut`. Subsequent reads from it will return its default value.
  mutating func clearSelectionShortcut() {_uniqueStorage()._selectionShortcut = nil}

  var characterFormRules: [Mozc_Config_Config.CharacterFormRule] {
    get {_storage._characterFormRules}
    set {_uniqueStorage()._characterFormRules = newValue}
  }

  /// Automatically switch composition mode.
  var autoSwitchCompositionMode: Bool {
    get {_storage._autoSwitchCompositionMode ?? true}
    set {_uniqueStorage()._autoSwitchCompositionMode = newValue}
  }
  /// Returns true if `autoSwitchCompositionMode` has been explicitly set.
  var hasAutoSwitchCompositionMode: Bool {_storage._autoSwitchCompositionMode != nil}
  /// Clears the value of `autoSwitchCompositionMode`. Subsequent reads from it will return its default value.
  mutating func clearAutoSwitchCompositionMode() {_uniqueStorage()._autoSwitchCompositionMode = nil}

  /// Toggle to use cascanding window for debugging.
  var useCascadingWindow: Bool {
    get {_storage._useCascadingWindow ?? true}
    set {_uniqueStorage()._useCascadingWindow = newValue}
  }
  /// Returns true if `useCascadingWindow` has been explicitly set.
  var hasUseCascadingWindow: Bool {_storage._useCascadingWindow != nil}
  /// Clears the value of `useCascadingWindow`. Subsequent reads from it will return its default value.
  mutating func clearUseCascadingWindow() {_uniqueStorage()._useCascadingWindow = nil}

  var shiftKeyModeSwitch: Mozc_Config_Config.ShiftKeyModeSwitch {
    get {_storage._shiftKeyModeSwitch ?? .asciiInputMode}
    set {_uniqueStorage()._shiftKeyModeSwitch = newValue}
  }
  /// Returns true if `shiftKeyModeSwitch` has been explicitly set.
  var hasShiftKeyModeSwitch: Bool {_storage._shiftKeyModeSwitch != nil}
  /// Clears the value of `shiftKeyModeSwitch`. Subsequent reads from it will return its default value.
  mutating func clearShiftKeyModeSwitch() {_uniqueStorage()._shiftKeyModeSwitch = nil}

  var numpadCharacterForm: Mozc_Config_Config.NumpadCharacterForm {
    get {_storage._numpadCharacterForm ?? .numpadHalfWidth}
    set {_uniqueStorage()._numpadCharacterForm = newValue}
  }
  /// Returns true if `numpadCharacterForm` has been explicitly set.
  var hasNumpadCharacterForm: Bool {_storage._numpadCharacterForm != nil}
  /// Clears the value of `numpadCharacterForm`. Subsequent reads from it will return its default value.
  mutating func clearNumpadCharacterForm() {_uniqueStorage()._numpadCharacterForm = nil}

  var useAutoConversion: Bool {
    get {_storage._useAutoConversion ?? false}
    set {_uniqueStorage()._useAutoConversion = newValue}
  }
  /// Returns true if `useAutoConversion` has been explicitly set.
  var hasUseAutoConversion: Bool {_storage._useAutoConversion != nil}
  /// Clears the value of `useAutoConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseAutoConversion() {_uniqueStorage()._useAutoConversion = nil}

  /// can't use AutoConversionKey as a type since
  /// undefined enum type is not correctly handled.
  var autoConversionKey: UInt32 {
    get {_storage._autoConversionKey ?? 13}
    set {_uniqueStorage()._autoConversionKey = newValue}
  }
  /// Returns true if `autoConversionKey` has been explicitly set.
  var hasAutoConversionKey: Bool {_storage._autoConversionKey != nil}
  /// Clears the value of `autoConversionKey`. Subsequent reads from it will return its default value.
  mutating func clearAutoConversionKey() {_uniqueStorage()._autoConversionKey = nil}

  /// Mac-original JIS key layout has "yen-sign" key which generates
  /// U+00A5 instead of U+005C and sometimes users get troubles with
  /// them because they expect backslashes which are rendered as
  /// yen-sign.  If this configuration is BACKSLASH, Mozc will
  /// interpret U+005C even when the original key event is U+00A5.
  var yenSignCharacter: Mozc_Config_Config.YenSignCharacter {
    get {_storage._yenSignCharacter ?? .yenSign}
    set {_uniqueStorage()._yenSignCharacter = newValue}
  }
  /// Returns true if `yenSignCharacter` has been explicitly set.
  var hasYenSignCharacter: Bool {_storage._yenSignCharacter != nil}
  /// Clears the value of `yenSignCharacter`. Subsequent reads from it will return its default value.
  mutating func clearYenSignCharacter() {_uniqueStorage()._yenSignCharacter = nil}

  /// Use Japanese keyboard layout even when the user uses other
  /// keyboard layouts.  In Mac OSX people can use several keyboard
  /// layouts such like French or Spanish but some people want to use
  /// Japanese layout for Japanese.  See http://b/2917320
  var useJapaneseLayout: Bool {
    get {_storage._useJapaneseLayout ?? false}
    set {_uniqueStorage()._useJapaneseLayout = newValue}
  }
  /// Returns true if `useJapaneseLayout` has been explicitly set.
  var hasUseJapaneseLayout: Bool {_storage._useJapaneseLayout != nil}
  /// Clears the value of `useJapaneseLayout`. Subsequent reads from it will return its default value.
  mutating func clearUseJapaneseLayout() {_uniqueStorage()._useJapaneseLayout = nil}

  /// Use kana modifier insensitive conversion.
  /// e.g. „Åã„Å§„Åì„ÅÜ -> Â≠¶Ê†°
  /// Note that Request message has the same field.
  /// - Request's one is controlled by the client. A user cannot control it.
  ///   On the other hand Config's is under a user's control.
  /// - Whether the feature is activated or not is decided by logical-AND
  ///   of Request's and Config's.
  var useKanaModifierInsensitiveConversion: Bool {
    get {_storage._useKanaModifierInsensitiveConversion ?? false}
    set {_uniqueStorage()._useKanaModifierInsensitiveConversion = newValue}
  }
  /// Returns true if `useKanaModifierInsensitiveConversion` has been explicitly set.
  var hasUseKanaModifierInsensitiveConversion: Bool {_storage._useKanaModifierInsensitiveConversion != nil}
  /// Clears the value of `useKanaModifierInsensitiveConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseKanaModifierInsensitiveConversion() {_uniqueStorage()._useKanaModifierInsensitiveConversion = nil}

  /// Use typing correction feature.
  /// e.g. sunkai -> Ê∑±Êµ∑
  var useTypingCorrection: Bool {
    get {_storage._useTypingCorrection ?? false}
    set {_uniqueStorage()._useTypingCorrection = newValue}
  }
  /// Returns true if `useTypingCorrection` has been explicitly set.
  var hasUseTypingCorrection: Bool {_storage._useTypingCorrection != nil}
  /// Clears the value of `useTypingCorrection`. Subsequent reads from it will return its default value.
  mutating func clearUseTypingCorrection() {_uniqueStorage()._useTypingCorrection = nil}

  /// The duration in millisecond to determine the timeout.
  /// If the duration between key inputs is more than this value,
  /// a SessionCommand::STOP_KEY_TOGGLING is prepended to the next key input.
  /// If the value is 0, STOP_KEY_TOGGLING is not sent.
  var composingTimeoutThresholdMsec: Int32 {
    get {_storage._composingTimeoutThresholdMsec ?? 0}
    set {_uniqueStorage()._composingTimeoutThresholdMsec = newValue}
  }
  /// Returns true if `composingTimeoutThresholdMsec` has been explicitly set.
  var hasComposingTimeoutThresholdMsec: Bool {_storage._composingTimeoutThresholdMsec != nil}
  /// Clears the value of `composingTimeoutThresholdMsec`. Subsequent reads from it will return its default value.
  mutating func clearComposingTimeoutThresholdMsec() {_uniqueStorage()._composingTimeoutThresholdMsec = nil}

  /// The keymaps which are loaded on top of `session_keymap`.
  /// Overlay keymaps are prioritized over `session_keymap`.
  /// They are used to partially modify the session keymap, for example
  /// using Henkan key as IME_ON.
  var overlayKeymaps: [Mozc_Config_Config.SessionKeymap] {
    get {_storage._overlayKeymaps}
    set {_uniqueStorage()._overlayKeymaps = newValue}
  }

  ///////////////////////////////////////////////////////////////
  ///
  /// Dictionary (80-99)
  var useDateConversion: Bool {
    get {_storage._useDateConversion ?? true}
    set {_uniqueStorage()._useDateConversion = newValue}
  }
  /// Returns true if `useDateConversion` has been explicitly set.
  var hasUseDateConversion: Bool {_storage._useDateConversion != nil}
  /// Clears the value of `useDateConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseDateConversion() {_uniqueStorage()._useDateConversion = nil}

  var useSingleKanjiConversion: Bool {
    get {_storage._useSingleKanjiConversion ?? true}
    set {_uniqueStorage()._useSingleKanjiConversion = newValue}
  }
  /// Returns true if `useSingleKanjiConversion` has been explicitly set.
  var hasUseSingleKanjiConversion: Bool {_storage._useSingleKanjiConversion != nil}
  /// Clears the value of `useSingleKanjiConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseSingleKanjiConversion() {_uniqueStorage()._useSingleKanjiConversion = nil}

  var useSymbolConversion: Bool {
    get {_storage._useSymbolConversion ?? true}
    set {_uniqueStorage()._useSymbolConversion = newValue}
  }
  /// Returns true if `useSymbolConversion` has been explicitly set.
  var hasUseSymbolConversion: Bool {_storage._useSymbolConversion != nil}
  /// Clears the value of `useSymbolConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseSymbolConversion() {_uniqueStorage()._useSymbolConversion = nil}

  var useNumberConversion: Bool {
    get {_storage._useNumberConversion ?? true}
    set {_uniqueStorage()._useNumberConversion = newValue}
  }
  /// Returns true if `useNumberConversion` has been explicitly set.
  var hasUseNumberConversion: Bool {_storage._useNumberConversion != nil}
  /// Clears the value of `useNumberConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseNumberConversion() {_uniqueStorage()._useNumberConversion = nil}

  var useEmoticonConversion: Bool {
    get {_storage._useEmoticonConversion ?? true}
    set {_uniqueStorage()._useEmoticonConversion = newValue}
  }
  /// Returns true if `useEmoticonConversion` has been explicitly set.
  var hasUseEmoticonConversion: Bool {_storage._useEmoticonConversion != nil}
  /// Clears the value of `useEmoticonConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseEmoticonConversion() {_uniqueStorage()._useEmoticonConversion = nil}

  var useCalculator: Bool {
    get {_storage._useCalculator ?? true}
    set {_uniqueStorage()._useCalculator = newValue}
  }
  /// Returns true if `useCalculator` has been explicitly set.
  var hasUseCalculator: Bool {_storage._useCalculator != nil}
  /// Clears the value of `useCalculator`. Subsequent reads from it will return its default value.
  mutating func clearUseCalculator() {_uniqueStorage()._useCalculator = nil}

  var useT13NConversion: Bool {
    get {_storage._useT13NConversion ?? true}
    set {_uniqueStorage()._useT13NConversion = newValue}
  }
  /// Returns true if `useT13NConversion` has been explicitly set.
  var hasUseT13NConversion: Bool {_storage._useT13NConversion != nil}
  /// Clears the value of `useT13NConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseT13NConversion() {_uniqueStorage()._useT13NConversion = nil}

  var useZipCodeConversion: Bool {
    get {_storage._useZipCodeConversion ?? true}
    set {_uniqueStorage()._useZipCodeConversion = newValue}
  }
  /// Returns true if `useZipCodeConversion` has been explicitly set.
  var hasUseZipCodeConversion: Bool {_storage._useZipCodeConversion != nil}
  /// Clears the value of `useZipCodeConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseZipCodeConversion() {_uniqueStorage()._useZipCodeConversion = nil}

  var useSpellingCorrection: Bool {
    get {_storage._useSpellingCorrection ?? true}
    set {_uniqueStorage()._useSpellingCorrection = newValue}
  }
  /// Returns true if `useSpellingCorrection` has been explicitly set.
  var hasUseSpellingCorrection: Bool {_storage._useSpellingCorrection != nil}
  /// Clears the value of `useSpellingCorrection`. Subsequent reads from it will return its default value.
  mutating func clearUseSpellingCorrection() {_uniqueStorage()._useSpellingCorrection = nil}

  /// If use_emoji_conversion is true, the user can input emoji characters
  /// by converting from a query string (e.g. "„ÅÑ„Å¨ ‚Üí üê∂" [U+1F436]).
  /// Even if it is false, users might be able to input emoji characters
  /// with other ways.
  /// Note: Some characters can be either of text and emoji.  It would be ideal
  /// to use the variation sequence to specify emoji presentation [U+FE0E],
  /// although it is not implemented yet.
  /// See: http://unicode.org/reports/tr51/#Presentation_Style
  var useEmojiConversion: Bool {
    get {_storage._useEmojiConversion ?? false}
    set {_uniqueStorage()._useEmojiConversion = newValue}
  }
  /// Returns true if `useEmojiConversion` has been explicitly set.
  var hasUseEmojiConversion: Bool {_storage._useEmojiConversion != nil}
  /// Clears the value of `useEmojiConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseEmojiConversion() {_uniqueStorage()._useEmojiConversion = nil}

  var informationListConfig: Mozc_Config_Config.InformationListConfig {
    get {_storage._informationListConfig ?? Mozc_Config_Config.InformationListConfig()}
    set {_uniqueStorage()._informationListConfig = newValue}
  }
  /// Returns true if `informationListConfig` has been explicitly set.
  var hasInformationListConfig: Bool {_storage._informationListConfig != nil}
  /// Clears the value of `informationListConfig`. Subsequent reads from it will return its default value.
  mutating func clearInformationListConfig() {_uniqueStorage()._informationListConfig = nil}

  ///////////////////////////////////////////////////////////////
  ///
  /// Suggest (100-119)
  ///
  /// Suggest is a feature of word suggestion with prefix search.
  /// When you type "„ÅÇ", you may get "„ÅÇ„Çä„Åå„Å®„ÅÜ", "Êúù" („ÅÇ„Åï), "ÊòéÊó•" („ÅÇ„Åó„Åü)
  /// as suggested words.
  ///
  /// Use history-based suggest feature.
  /// If this is true, your previously typed words are prioritized.
  var useHistorySuggest: Bool {
    get {_storage._useHistorySuggest ?? true}
    set {_uniqueStorage()._useHistorySuggest = newValue}
  }
  /// Returns true if `useHistorySuggest` has been explicitly set.
  var hasUseHistorySuggest: Bool {_storage._useHistorySuggest != nil}
  /// Clears the value of `useHistorySuggest`. Subsequent reads from it will return its default value.
  mutating func clearUseHistorySuggest() {_uniqueStorage()._useHistorySuggest = nil}

  /// Use dictionary-based suggest feature.
  /// If this is true, words in the word dictionary are suggested even if
  /// you haven't typed before.
  var useDictionarySuggest: Bool {
    get {_storage._useDictionarySuggest ?? true}
    set {_uniqueStorage()._useDictionarySuggest = newValue}
  }
  /// Returns true if `useDictionarySuggest` has been explicitly set.
  var hasUseDictionarySuggest: Bool {_storage._useDictionarySuggest != nil}
  /// Clears the value of `useDictionarySuggest`. Subsequent reads from it will return its default value.
  mutating func clearUseDictionarySuggest() {_uniqueStorage()._useDictionarySuggest = nil}

  /// Use realtime conversion feature.
  var useRealtimeConversion: Bool {
    get {_storage._useRealtimeConversion ?? true}
    set {_uniqueStorage()._useRealtimeConversion = newValue}
  }
  /// Returns true if `useRealtimeConversion` has been explicitly set.
  var hasUseRealtimeConversion: Bool {_storage._useRealtimeConversion != nil}
  /// Clears the value of `useRealtimeConversion`. Subsequent reads from it will return its default value.
  mutating func clearUseRealtimeConversion() {_uniqueStorage()._useRealtimeConversion = nil}

  /// Size of suggestions.
  var suggestionsSize: UInt32 {
    get {_storage._suggestionsSize ?? 3}
    set {_uniqueStorage()._suggestionsSize = newValue}
  }
  /// Returns true if `suggestionsSize` has been explicitly set.
  var hasSuggestionsSize: Bool {_storage._suggestionsSize != nil}
  /// Clears the value of `suggestionsSize`. Subsequent reads from it will return its default value.
  mutating func clearSuggestionsSize() {_uniqueStorage()._suggestionsSize = nil}

  ///////////////////////////////////////////////////////////////
  ///
  /// Renderer (120-139)
  ///
  /// Use mode indicator feature.
  var useModeIndicator: Bool {
    get {_storage._useModeIndicator ?? true}
    set {_uniqueStorage()._useModeIndicator = newValue}
  }
  /// Returns true if `useModeIndicator` has been explicitly set.
  var hasUseModeIndicator: Bool {_storage._useModeIndicator != nil}
  /// Clears the value of `useModeIndicator`. Subsequent reads from it will return its default value.
  mutating func clearUseModeIndicator() {_uniqueStorage()._useModeIndicator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///////////////////////////////////////////////////////////////
  ///
  /// Basic features (40-79)
  enum PreeditMethod: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case roman = 0
    case kana = 1

    init() {
      self = .roman
    }

  }

  enum SessionKeymap: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// If NONE is selected, it will be replaced with MSIME or KOTOERI.
    /// NONE is used only for a placeholder, so a configuration program
    /// should not show NONE as one of selections.  NONE should be the
    /// last of the items due to the limitation of the Qt GUI's
    /// implementation. Note that keymap number should be correspoinding
    /// to the index of QComboBox in config dialog. Since NONE is not
    /// used, we set -1 here.
    case none = -1
    case custom = 0
    case atok = 1
    case msime = 2
    case kotoeri = 3
    case mobile = 4
    case chromeos = 5
    case overlayHenkanMuhenkanToImeOnOff = 100
    case overlayForTest = 10000

    init() {
      self = .none
    }

  }

  enum PunctuationMethod: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case toutenKuten = 0
    case commaPeriod = 1
    case toutenPeriod = 2
    case commaKuten = 3

    init() {
      self = .toutenKuten
    }

  }

  enum SymbolMethod: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case cornerBracketMiddleDot = 0
    case squareBracketSlash = 1
    case cornerBracketSlash = 2
    case squareBracketMiddleDot = 3

    init() {
      self = .cornerBracketMiddleDot
    }

  }

  enum FundamentalCharacterForm: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// follow the input mode
    case fundamentalInputMode = 0

    /// always FullWidth
    case fundamentalFullWidth = 1

    /// always HalfWidth
    case fundamentalHalfWidth = 2

    init() {
      self = .fundamentalInputMode
    }

  }

  /// User history learning
  enum HistoryLearningLevel: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case defaultHistory = 0
    case readOnly = 1
    case noHistory = 2

    init() {
      self = .defaultHistory
    }

  }

  /// The style of candidate selection shortcut.
  /// Note that if the current Request has SpecialRomajiTable (== the keyevent
  /// is from a virtual keyboard), shortcut is no-op.
  enum SelectionShortcut: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case noShortcut = 0
    case shortcut123456789 = 1
    case shortcutAsdfghjkl = 2

    init() {
      self = .noShortcut
    }

  }

  /// character form (Halfwidth/Fullwidth
  enum CharacterForm: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case halfWidth = 0
    case fullWidth = 1
    case lastForm = 2
    case noConversion = 3

    init() {
      self = .halfWidth
    }

  }

  /// Shift key mode switch
  enum ShiftKeyModeSwitch: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Case insensitive
    case off = 0

    /// MSIME, ATOK behavior
    case asciiInputMode = 1

    /// Kotoeri behavior
    case katakanaInputMode = 2

    init() {
      self = .off
    }

  }

  enum NumpadCharacterForm: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case numpadInputMode = 0
    case numpadFullWidth = 1
    case numpadHalfWidth = 2
    case numpadDirectInput = 3

    init() {
      self = .numpadInputMode
    }

  }

  enum AutoConversionKey: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case autoConversionOff = 0
    case autoConversionKuten = 1
    case autoConversionTouten = 2
    case autoConversionQuestionMark = 4
    case autoConversionExclamationMark = 8

    init() {
      self = .autoConversionOff
    }

  }

  /// Mac only config items: yen_sign_character and use_japanese_layout.
  enum YenSignCharacter: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case yenSign = 0
    case backslash = 1

    init() {
      self = .yenSign
    }

  }

  struct CharacterFormRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var group: String {
      get {_group ?? String()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    var hasGroup: Bool {self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    mutating func clearGroup() {self._group = nil}

    var preeditCharacterForm: Mozc_Config_Config.CharacterForm {
      get {_preeditCharacterForm ?? .fullWidth}
      set {_preeditCharacterForm = newValue}
    }
    /// Returns true if `preeditCharacterForm` has been explicitly set.
    var hasPreeditCharacterForm: Bool {self._preeditCharacterForm != nil}
    /// Clears the value of `preeditCharacterForm`. Subsequent reads from it will return its default value.
    mutating func clearPreeditCharacterForm() {self._preeditCharacterForm = nil}

    var conversionCharacterForm: Mozc_Config_Config.CharacterForm {
      get {_conversionCharacterForm ?? .fullWidth}
      set {_conversionCharacterForm = newValue}
    }
    /// Returns true if `conversionCharacterForm` has been explicitly set.
    var hasConversionCharacterForm: Bool {self._conversionCharacterForm != nil}
    /// Clears the value of `conversionCharacterForm`. Subsequent reads from it will return its default value.
    mutating func clearConversionCharacterForm() {self._conversionCharacterForm = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _group: String? = nil
    fileprivate var _preeditCharacterForm: Mozc_Config_Config.CharacterForm? = nil
    fileprivate var _conversionCharacterForm: Mozc_Config_Config.CharacterForm? = nil
  }

  struct InformationListConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var useLocalUsageDictionary: Bool {
      get {_useLocalUsageDictionary ?? true}
      set {_useLocalUsageDictionary = newValue}
    }
    /// Returns true if `useLocalUsageDictionary` has been explicitly set.
    var hasUseLocalUsageDictionary: Bool {self._useLocalUsageDictionary != nil}
    /// Clears the value of `useLocalUsageDictionary`. Subsequent reads from it will return its default value.
    mutating func clearUseLocalUsageDictionary() {self._useLocalUsageDictionary = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _useLocalUsageDictionary: Bool? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mozc.config"

extension Mozc_Config_GeneralConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GeneralConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}config_version\0\u{3}last_modified_product_version\0\u{3}last_modified_time\0\u{1}platform\0\u{3}ui_locale\0\u{3}upload_usage_stats\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._configVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._lastModifiedProductVersion) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._lastModifiedTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._platform) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._uiLocale) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._uploadUsageStats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lastModifiedProductVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastModifiedTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._platform {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._uiLocale {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._uploadUsageStats {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Config_GeneralConfig, rhs: Mozc_Config_GeneralConfig) -> Bool {
    if lhs._configVersion != rhs._configVersion {return false}
    if lhs._lastModifiedProductVersion != rhs._lastModifiedProductVersion {return false}
    if lhs._lastModifiedTime != rhs._lastModifiedTime {return false}
    if lhs._platform != rhs._platform {return false}
    if lhs._uiLocale != rhs._uiLocale {return false}
    if lhs._uploadUsageStats != rhs._uploadUsageStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Config_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Config"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}general_config\0\u{4}\u{9}verbose_level\0\u{4}\u{a}incognito_mode\0\u{4}\u{2}check_default\0\u{3}presentation_mode\0\u{4}\u{11}preedit_method\0\u{3}session_keymap\0\u{3}custom_keymap_table\0\u{3}custom_roman_table\0\u{4}\u{2}punctuation_method\0\u{3}symbol_method\0\u{3}space_character_form\0\u{3}use_keyboard_to_change_preedit_method\0\u{4}\u{2}history_learning_level\0\u{4}\u{2}selection_shortcut\0\u{4}\u{2}character_form_rules\0\u{4}\u{2}auto_switch_composition_mode\0\u{4}\u{2}use_cascading_window\0\u{3}shift_key_mode_switch\0\u{3}numpad_character_form\0\u{3}use_auto_conversion\0\u{3}auto_conversion_key\0\u{3}yen_sign_character\0\u{3}use_japanese_layout\0\u{3}use_kana_modifier_insensitive_conversion\0\u{3}use_typing_correction\0\u{3}composing_timeout_threshold_msec\0\u{3}overlay_keymaps\0\u{4}\u{c}use_date_conversion\0\u{3}use_single_kanji_conversion\0\u{3}use_symbol_conversion\0\u{3}use_number_conversion\0\u{3}use_emoticon_conversion\0\u{3}use_calculator\0\u{3}use_t13n_conversion\0\u{3}use_zip_code_conversion\0\u{3}use_spelling_correction\0\u{3}use_emoji_conversion\0\u{3}information_list_config\0\u{4}\u{a}use_history_suggest\0\u{3}use_dictionary_suggest\0\u{3}use_realtime_conversion\0\u{4}\u{8}suggestions_size\0\u{4}\u{a}use_mode_indicator\0\u{b}log_all_commands\0\u{b}upload_usage_stats\0\u{b}sync_config\0\u{b}allow_cloud_handwriting\0\u{b}pinyin_config\0\u{b}hangul_config\0\u{b}chewing_config\0\u{c}\u{2}\u{8}\u{c}\u{b}\u{1}\u{c}\u{15}\u{1}\u{c}l\u{4}\u{1}\u{c}m\u{4}\u{1}\u{c}d\u{f}\u{1}\u{c}f\u{f}\u{1}\u{c}g\u{f}\u{1}")

  fileprivate class _StorageClass {
    var _generalConfig: Mozc_Config_GeneralConfig? = nil
    var _verboseLevel: Int32? = nil
    var _incognitoMode: Bool? = nil
    var _checkDefault: Bool? = nil
    var _presentationMode: Bool? = nil
    var _preeditMethod: Mozc_Config_Config.PreeditMethod? = nil
    var _sessionKeymap: Mozc_Config_Config.SessionKeymap? = nil
    var _customKeymapTable: Data? = nil
    var _customRomanTable: Data? = nil
    var _punctuationMethod: Mozc_Config_Config.PunctuationMethod? = nil
    var _symbolMethod: Mozc_Config_Config.SymbolMethod? = nil
    var _spaceCharacterForm: Mozc_Config_Config.FundamentalCharacterForm? = nil
    var _useKeyboardToChangePreeditMethod: Bool? = nil
    var _historyLearningLevel: Mozc_Config_Config.HistoryLearningLevel? = nil
    var _selectionShortcut: Mozc_Config_Config.SelectionShortcut? = nil
    var _characterFormRules: [Mozc_Config_Config.CharacterFormRule] = []
    var _autoSwitchCompositionMode: Bool? = nil
    var _useCascadingWindow: Bool? = nil
    var _shiftKeyModeSwitch: Mozc_Config_Config.ShiftKeyModeSwitch? = nil
    var _numpadCharacterForm: Mozc_Config_Config.NumpadCharacterForm? = nil
    var _useAutoConversion: Bool? = nil
    var _autoConversionKey: UInt32? = nil
    var _yenSignCharacter: Mozc_Config_Config.YenSignCharacter? = nil
    var _useJapaneseLayout: Bool? = nil
    var _useKanaModifierInsensitiveConversion: Bool? = nil
    var _useTypingCorrection: Bool? = nil
    var _composingTimeoutThresholdMsec: Int32? = nil
    var _overlayKeymaps: [Mozc_Config_Config.SessionKeymap] = []
    var _useDateConversion: Bool? = nil
    var _useSingleKanjiConversion: Bool? = nil
    var _useSymbolConversion: Bool? = nil
    var _useNumberConversion: Bool? = nil
    var _useEmoticonConversion: Bool? = nil
    var _useCalculator: Bool? = nil
    var _useT13NConversion: Bool? = nil
    var _useZipCodeConversion: Bool? = nil
    var _useSpellingCorrection: Bool? = nil
    var _useEmojiConversion: Bool? = nil
    var _informationListConfig: Mozc_Config_Config.InformationListConfig? = nil
    var _useHistorySuggest: Bool? = nil
    var _useDictionarySuggest: Bool? = nil
    var _useRealtimeConversion: Bool? = nil
    var _suggestionsSize: UInt32? = nil
    var _useModeIndicator: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _generalConfig = source._generalConfig
      _verboseLevel = source._verboseLevel
      _incognitoMode = source._incognitoMode
      _checkDefault = source._checkDefault
      _presentationMode = source._presentationMode
      _preeditMethod = source._preeditMethod
      _sessionKeymap = source._sessionKeymap
      _customKeymapTable = source._customKeymapTable
      _customRomanTable = source._customRomanTable
      _punctuationMethod = source._punctuationMethod
      _symbolMethod = source._symbolMethod
      _spaceCharacterForm = source._spaceCharacterForm
      _useKeyboardToChangePreeditMethod = source._useKeyboardToChangePreeditMethod
      _historyLearningLevel = source._historyLearningLevel
      _selectionShortcut = source._selectionShortcut
      _characterFormRules = source._characterFormRules
      _autoSwitchCompositionMode = source._autoSwitchCompositionMode
      _useCascadingWindow = source._useCascadingWindow
      _shiftKeyModeSwitch = source._shiftKeyModeSwitch
      _numpadCharacterForm = source._numpadCharacterForm
      _useAutoConversion = source._useAutoConversion
      _autoConversionKey = source._autoConversionKey
      _yenSignCharacter = source._yenSignCharacter
      _useJapaneseLayout = source._useJapaneseLayout
      _useKanaModifierInsensitiveConversion = source._useKanaModifierInsensitiveConversion
      _useTypingCorrection = source._useTypingCorrection
      _composingTimeoutThresholdMsec = source._composingTimeoutThresholdMsec
      _overlayKeymaps = source._overlayKeymaps
      _useDateConversion = source._useDateConversion
      _useSingleKanjiConversion = source._useSingleKanjiConversion
      _useSymbolConversion = source._useSymbolConversion
      _useNumberConversion = source._useNumberConversion
      _useEmoticonConversion = source._useEmoticonConversion
      _useCalculator = source._useCalculator
      _useT13NConversion = source._useT13NConversion
      _useZipCodeConversion = source._useZipCodeConversion
      _useSpellingCorrection = source._useSpellingCorrection
      _useEmojiConversion = source._useEmojiConversion
      _informationListConfig = source._informationListConfig
      _useHistorySuggest = source._useHistorySuggest
      _useDictionarySuggest = source._useDictionarySuggest
      _useRealtimeConversion = source._useRealtimeConversion
      _suggestionsSize = source._suggestionsSize
      _useModeIndicator = source._useModeIndicator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._generalConfig) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._verboseLevel) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._incognitoMode) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._checkDefault) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._presentationMode) }()
        case 40: try { try decoder.decodeSingularEnumField(value: &_storage._preeditMethod) }()
        case 41: try { try decoder.decodeSingularEnumField(value: &_storage._sessionKeymap) }()
        case 42: try { try decoder.decodeSingularBytesField(value: &_storage._customKeymapTable) }()
        case 43: try { try decoder.decodeSingularBytesField(value: &_storage._customRomanTable) }()
        case 45: try { try decoder.decodeSingularEnumField(value: &_storage._punctuationMethod) }()
        case 46: try { try decoder.decodeSingularEnumField(value: &_storage._symbolMethod) }()
        case 47: try { try decoder.decodeSingularEnumField(value: &_storage._spaceCharacterForm) }()
        case 48: try { try decoder.decodeSingularBoolField(value: &_storage._useKeyboardToChangePreeditMethod) }()
        case 50: try { try decoder.decodeSingularEnumField(value: &_storage._historyLearningLevel) }()
        case 52: try { try decoder.decodeSingularEnumField(value: &_storage._selectionShortcut) }()
        case 54: try { try decoder.decodeRepeatedMessageField(value: &_storage._characterFormRules) }()
        case 56: try { try decoder.decodeSingularBoolField(value: &_storage._autoSwitchCompositionMode) }()
        case 58: try { try decoder.decodeSingularBoolField(value: &_storage._useCascadingWindow) }()
        case 59: try { try decoder.decodeSingularEnumField(value: &_storage._shiftKeyModeSwitch) }()
        case 60: try { try decoder.decodeSingularEnumField(value: &_storage._numpadCharacterForm) }()
        case 61: try { try decoder.decodeSingularBoolField(value: &_storage._useAutoConversion) }()
        case 62: try { try decoder.decodeSingularUInt32Field(value: &_storage._autoConversionKey) }()
        case 63: try { try decoder.decodeSingularEnumField(value: &_storage._yenSignCharacter) }()
        case 64: try { try decoder.decodeSingularBoolField(value: &_storage._useJapaneseLayout) }()
        case 65: try { try decoder.decodeSingularBoolField(value: &_storage._useKanaModifierInsensitiveConversion) }()
        case 66: try { try decoder.decodeSingularBoolField(value: &_storage._useTypingCorrection) }()
        case 67: try { try decoder.decodeSingularInt32Field(value: &_storage._composingTimeoutThresholdMsec) }()
        case 68: try { try decoder.decodeRepeatedEnumField(value: &_storage._overlayKeymaps) }()
        case 80: try { try decoder.decodeSingularBoolField(value: &_storage._useDateConversion) }()
        case 81: try { try decoder.decodeSingularBoolField(value: &_storage._useSingleKanjiConversion) }()
        case 82: try { try decoder.decodeSingularBoolField(value: &_storage._useSymbolConversion) }()
        case 83: try { try decoder.decodeSingularBoolField(value: &_storage._useNumberConversion) }()
        case 84: try { try decoder.decodeSingularBoolField(value: &_storage._useEmoticonConversion) }()
        case 85: try { try decoder.decodeSingularBoolField(value: &_storage._useCalculator) }()
        case 86: try { try decoder.decodeSingularBoolField(value: &_storage._useT13NConversion) }()
        case 87: try { try decoder.decodeSingularBoolField(value: &_storage._useZipCodeConversion) }()
        case 88: try { try decoder.decodeSingularBoolField(value: &_storage._useSpellingCorrection) }()
        case 89: try { try decoder.decodeSingularBoolField(value: &_storage._useEmojiConversion) }()
        case 90: try { try decoder.decodeSingularMessageField(value: &_storage._informationListConfig) }()
        case 100: try { try decoder.decodeSingularBoolField(value: &_storage._useHistorySuggest) }()
        case 101: try { try decoder.decodeSingularBoolField(value: &_storage._useDictionarySuggest) }()
        case 102: try { try decoder.decodeSingularBoolField(value: &_storage._useRealtimeConversion) }()
        case 110: try { try decoder.decodeSingularUInt32Field(value: &_storage._suggestionsSize) }()
        case 120: try { try decoder.decodeSingularBoolField(value: &_storage._useModeIndicator) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._generalConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._verboseLevel {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._incognitoMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._checkDefault {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._presentationMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._preeditMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._sessionKeymap {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._customKeymapTable {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._customRomanTable {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._punctuationMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._symbolMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 46)
      } }()
      try { if let v = _storage._spaceCharacterForm {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 47)
      } }()
      try { if let v = _storage._useKeyboardToChangePreeditMethod {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 48)
      } }()
      try { if let v = _storage._historyLearningLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 50)
      } }()
      try { if let v = _storage._selectionShortcut {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 52)
      } }()
      if !_storage._characterFormRules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._characterFormRules, fieldNumber: 54)
      }
      try { if let v = _storage._autoSwitchCompositionMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 56)
      } }()
      try { if let v = _storage._useCascadingWindow {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 58)
      } }()
      try { if let v = _storage._shiftKeyModeSwitch {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 59)
      } }()
      try { if let v = _storage._numpadCharacterForm {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 60)
      } }()
      try { if let v = _storage._useAutoConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 61)
      } }()
      try { if let v = _storage._autoConversionKey {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 62)
      } }()
      try { if let v = _storage._yenSignCharacter {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 63)
      } }()
      try { if let v = _storage._useJapaneseLayout {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 64)
      } }()
      try { if let v = _storage._useKanaModifierInsensitiveConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 65)
      } }()
      try { if let v = _storage._useTypingCorrection {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 66)
      } }()
      try { if let v = _storage._composingTimeoutThresholdMsec {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 67)
      } }()
      if !_storage._overlayKeymaps.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._overlayKeymaps, fieldNumber: 68)
      }
      try { if let v = _storage._useDateConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 80)
      } }()
      try { if let v = _storage._useSingleKanjiConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 81)
      } }()
      try { if let v = _storage._useSymbolConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 82)
      } }()
      try { if let v = _storage._useNumberConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 83)
      } }()
      try { if let v = _storage._useEmoticonConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 84)
      } }()
      try { if let v = _storage._useCalculator {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 85)
      } }()
      try { if let v = _storage._useT13NConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 86)
      } }()
      try { if let v = _storage._useZipCodeConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 87)
      } }()
      try { if let v = _storage._useSpellingCorrection {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 88)
      } }()
      try { if let v = _storage._useEmojiConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 89)
      } }()
      try { if let v = _storage._informationListConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      } }()
      try { if let v = _storage._useHistorySuggest {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 100)
      } }()
      try { if let v = _storage._useDictionarySuggest {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 101)
      } }()
      try { if let v = _storage._useRealtimeConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 102)
      } }()
      try { if let v = _storage._suggestionsSize {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 110)
      } }()
      try { if let v = _storage._useModeIndicator {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 120)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Config_Config, rhs: Mozc_Config_Config) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._generalConfig != rhs_storage._generalConfig {return false}
        if _storage._verboseLevel != rhs_storage._verboseLevel {return false}
        if _storage._incognitoMode != rhs_storage._incognitoMode {return false}
        if _storage._checkDefault != rhs_storage._checkDefault {return false}
        if _storage._presentationMode != rhs_storage._presentationMode {return false}
        if _storage._preeditMethod != rhs_storage._preeditMethod {return false}
        if _storage._sessionKeymap != rhs_storage._sessionKeymap {return false}
        if _storage._customKeymapTable != rhs_storage._customKeymapTable {return false}
        if _storage._customRomanTable != rhs_storage._customRomanTable {return false}
        if _storage._punctuationMethod != rhs_storage._punctuationMethod {return false}
        if _storage._symbolMethod != rhs_storage._symbolMethod {return false}
        if _storage._spaceCharacterForm != rhs_storage._spaceCharacterForm {return false}
        if _storage._useKeyboardToChangePreeditMethod != rhs_storage._useKeyboardToChangePreeditMethod {return false}
        if _storage._historyLearningLevel != rhs_storage._historyLearningLevel {return false}
        if _storage._selectionShortcut != rhs_storage._selectionShortcut {return false}
        if _storage._characterFormRules != rhs_storage._characterFormRules {return false}
        if _storage._autoSwitchCompositionMode != rhs_storage._autoSwitchCompositionMode {return false}
        if _storage._useCascadingWindow != rhs_storage._useCascadingWindow {return false}
        if _storage._shiftKeyModeSwitch != rhs_storage._shiftKeyModeSwitch {return false}
        if _storage._numpadCharacterForm != rhs_storage._numpadCharacterForm {return false}
        if _storage._useAutoConversion != rhs_storage._useAutoConversion {return false}
        if _storage._autoConversionKey != rhs_storage._autoConversionKey {return false}
        if _storage._yenSignCharacter != rhs_storage._yenSignCharacter {return false}
        if _storage._useJapaneseLayout != rhs_storage._useJapaneseLayout {return false}
        if _storage._useKanaModifierInsensitiveConversion != rhs_storage._useKanaModifierInsensitiveConversion {return false}
        if _storage._useTypingCorrection != rhs_storage._useTypingCorrection {return false}
        if _storage._composingTimeoutThresholdMsec != rhs_storage._composingTimeoutThresholdMsec {return false}
        if _storage._overlayKeymaps != rhs_storage._overlayKeymaps {return false}
        if _storage._useDateConversion != rhs_storage._useDateConversion {return false}
        if _storage._useSingleKanjiConversion != rhs_storage._useSingleKanjiConversion {return false}
        if _storage._useSymbolConversion != rhs_storage._useSymbolConversion {return false}
        if _storage._useNumberConversion != rhs_storage._useNumberConversion {return false}
        if _storage._useEmoticonConversion != rhs_storage._useEmoticonConversion {return false}
        if _storage._useCalculator != rhs_storage._useCalculator {return false}
        if _storage._useT13NConversion != rhs_storage._useT13NConversion {return false}
        if _storage._useZipCodeConversion != rhs_storage._useZipCodeConversion {return false}
        if _storage._useSpellingCorrection != rhs_storage._useSpellingCorrection {return false}
        if _storage._useEmojiConversion != rhs_storage._useEmojiConversion {return false}
        if _storage._informationListConfig != rhs_storage._informationListConfig {return false}
        if _storage._useHistorySuggest != rhs_storage._useHistorySuggest {return false}
        if _storage._useDictionarySuggest != rhs_storage._useDictionarySuggest {return false}
        if _storage._useRealtimeConversion != rhs_storage._useRealtimeConversion {return false}
        if _storage._suggestionsSize != rhs_storage._suggestionsSize {return false}
        if _storage._useModeIndicator != rhs_storage._useModeIndicator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Config_Config.PreeditMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ROMAN\0\u{1}KANA\0")
}

extension Mozc_Config_Config.SessionKeymap: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{7f}\u{7f}\u{7f}\u{7f}\u{7f}\u{3}NONE\0\u{1}CUSTOM\0\u{1}ATOK\0\u{1}MSIME\0\u{1}KOTOERI\0\u{1}MOBILE\0\u{1}CHROMEOS\0\u{2}_\u{1}OVERLAY_HENKAN_MUHENKAN_TO_IME_ON_OFF\0\u{2}lZ\u{2}OVERLAY_FOR_TEST\0")
}

extension Mozc_Config_Config.PunctuationMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TOUTEN_KUTEN\0\u{1}COMMA_PERIOD\0\u{1}TOUTEN_PERIOD\0\u{1}COMMA_KUTEN\0")
}

extension Mozc_Config_Config.SymbolMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CORNER_BRACKET_MIDDLE_DOT\0\u{1}SQUARE_BRACKET_SLASH\0\u{1}CORNER_BRACKET_SLASH\0\u{1}SQUARE_BRACKET_MIDDLE_DOT\0")
}

extension Mozc_Config_Config.FundamentalCharacterForm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FUNDAMENTAL_INPUT_MODE\0\u{1}FUNDAMENTAL_FULL_WIDTH\0\u{1}FUNDAMENTAL_HALF_WIDTH\0")
}

extension Mozc_Config_Config.HistoryLearningLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT_HISTORY\0\u{1}READ_ONLY\0\u{1}NO_HISTORY\0")
}

extension Mozc_Config_Config.SelectionShortcut: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NO_SHORTCUT\0\u{1}SHORTCUT_123456789\0\u{1}SHORTCUT_ASDFGHJKL\0")
}

extension Mozc_Config_Config.CharacterForm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HALF_WIDTH\0\u{1}FULL_WIDTH\0\u{1}LAST_FORM\0\u{1}NO_CONVERSION\0")
}

extension Mozc_Config_Config.ShiftKeyModeSwitch: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OFF\0\u{1}ASCII_INPUT_MODE\0\u{1}KATAKANA_INPUT_MODE\0")
}

extension Mozc_Config_Config.NumpadCharacterForm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NUMPAD_INPUT_MODE\0\u{1}NUMPAD_FULL_WIDTH\0\u{1}NUMPAD_HALF_WIDTH\0\u{1}NUMPAD_DIRECT_INPUT\0")
}

extension Mozc_Config_Config.AutoConversionKey: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0AUTO_CONVERSION_OFF\0\u{1}AUTO_CONVERSION_KUTEN\0\u{1}AUTO_CONVERSION_TOUTEN\0\u{2}\u{2}AUTO_CONVERSION_QUESTION_MARK\0\u{2}\u{4}AUTO_CONVERSION_EXCLAMATION_MARK\0")
}

extension Mozc_Config_Config.YenSignCharacter: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0YEN_SIGN\0\u{1}BACKSLASH\0")
}

extension Mozc_Config_Config.CharacterFormRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Config_Config.protoMessageName + ".CharacterFormRule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}group\0\u{3}preedit_character_form\0\u{3}conversion_character_form\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._preeditCharacterForm) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._conversionCharacterForm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._preeditCharacterForm {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._conversionCharacterForm {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Config_Config.CharacterFormRule, rhs: Mozc_Config_Config.CharacterFormRule) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._preeditCharacterForm != rhs._preeditCharacterForm {return false}
    if lhs._conversionCharacterForm != rhs._conversionCharacterForm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Config_Config.InformationListConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Config_Config.protoMessageName + ".InformationListConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}use_local_usage_dictionary\0\u{b}use_web_usage_dictionary\0\u{b}web_service_entries\0\u{c}\u{2}\u{1}\u{c}\u{a}\u{1}")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._useLocalUsageDictionary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._useLocalUsageDictionary {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Config_Config.InformationListConfig, rhs: Mozc_Config_Config.InformationListConfig) -> Bool {
    if lhs._useLocalUsageDictionary != rhs._useLocalUsageDictionary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
