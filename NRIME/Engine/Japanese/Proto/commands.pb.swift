// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocol/commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2010-2021, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Protocol messages to be used for mozc client/server communication.
//
// The Command message contains all the input/output values for
// client/server commnication.  The messages structure of Command and
// its child messages are here:

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// This enum is used by SessionCommand::input_mode with
/// CHANGE_INPUT_MODE and Output::mode.
enum Mozc_Commands_CompositionMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
  case direct = 0
  case hiragana = 1
  case fullKatakana = 2
  case halfAscii = 3
  case fullAscii = 4
  case halfKatakana = 5
  case numOfCompositions = 6

  init() {
    self = .direct
  }

}

struct Mozc_Commands_KeyEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Printable key in UCS4.  If key_code is empty, key_string is used
  /// as a raw input.
  var keyCode: UInt32 {
    get {_keyCode ?? 0}
    set {_keyCode = newValue}
  }
  /// Returns true if `keyCode` has been explicitly set.
  var hasKeyCode: Bool {self._keyCode != nil}
  /// Clears the value of `keyCode`. Subsequent reads from it will return its default value.
  mutating func clearKeyCode() {self._keyCode = nil}

  /// Going to be obsolete.
  var modifiers: UInt32 {
    get {_modifiers ?? 0}
    set {_modifiers = newValue}
  }
  /// Returns true if `modifiers` has been explicitly set.
  var hasModifiers: Bool {self._modifiers != nil}
  /// Clears the value of `modifiers`. Subsequent reads from it will return its default value.
  mutating func clearModifiers() {self._modifiers = nil}

  /// Unprintable key listed above.
  var specialKey: Mozc_Commands_KeyEvent.SpecialKey {
    get {_specialKey ?? .noSpecialkey}
    set {_specialKey = newValue}
  }
  /// Returns true if `specialKey` has been explicitly set.
  var hasSpecialKey: Bool {self._specialKey != nil}
  /// Clears the value of `specialKey`. Subsequent reads from it will return its default value.
  mutating func clearSpecialKey() {self._specialKey = nil}

  /// ModifierKeys
  var modifierKeys: [Mozc_Commands_KeyEvent.ModifierKey] = []

  /// String used for preedit.  Kana characters and strings typed from
  /// a software keyboard are supposed to be stored here.  If key_code
  /// is also set, key_code is treated as the raw input and key_string is
  /// treated as the composition input.  For example, to set Kana value,
  /// when key_string is "ち", key_code should be 'a' (97).  If key_code
  /// is empty, key_string is also treated as the raw input.
  var keyString: String {
    get {_keyString ?? String()}
    set {_keyString = newValue}
  }
  /// Returns true if `keyString` has been explicitly set.
  var hasKeyString: Bool {self._keyString != nil}
  /// Clears the value of `keyString`. Subsequent reads from it will return its default value.
  mutating func clearKeyString() {self._keyString = nil}

  var inputStyle: Mozc_Commands_KeyEvent.InputStyle {
    get {_inputStyle ?? .followMode}
    set {_inputStyle = newValue}
  }
  /// Returns true if `inputStyle` has been explicitly set.
  var hasInputStyle: Bool {self._inputStyle != nil}
  /// Clears the value of `inputStyle`. Subsequent reads from it will return its default value.
  mutating func clearInputStyle() {self._inputStyle = nil}

  /// Composition mode
  /// For histrical reasons, this field expects a temporary conversion
  /// mode rather than comeback input mode.
  var mode: Mozc_Commands_CompositionMode {
    get {_mode ?? .direct}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  /// Probable key events
  /// Even if you can fill this field,
  /// don't omit Input.key_code and so on
  /// because preedit string is composed based on them.
  var probableKeyEvent: [Mozc_Commands_KeyEvent.ProbableKeyEvent] = []

  /// IME on/off mode
  /// You can use this field to change the IME on/off mode indirectly without
  /// sending SpecialKey:ON or SpecialKey:OFF events.
  /// If the internal ImeContext::State is DIRECT and this field is true, the
  /// converter will change the state to PRECONPOSITION and then handles this key
  /// event.
  /// If the internal ImeContext::State is not DIRECT and this field is false,
  /// the converter will change the state to DIRECT and then handles this key
  /// event.
  /// Implementation note: We need both |mode| and |activated| to support
  /// indirect IME off, where |mode| should contain the next mode. If this field
  /// is not set, the server will act as if indirect on/off was not supported.
  var activated: Bool {
    get {_activated ?? false}
    set {_activated = newValue}
  }
  /// Returns true if `activated` has been explicitly set.
  var hasActivated: Bool {self._activated != nil}
  /// Clears the value of `activated`. Subsequent reads from it will return its default value.
  mutating func clearActivated() {self._activated = nil}

  /// Timestamp of this key event in millisecond.
  var timestampMsec: Int64 {
    get {_timestampMsec ?? 0}
    set {_timestampMsec = newValue}
  }
  /// Returns true if `timestampMsec` has been explicitly set.
  var hasTimestampMsec: Bool {self._timestampMsec != nil}
  /// Clears the value of `timestampMsec`. Subsequent reads from it will return its default value.
  mutating func clearTimestampMsec() {self._timestampMsec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// LINT.IfChange
  enum SpecialKey: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case noSpecialkey = 0
    case digit = 1

    /// On Windows, SpecialKey::On and SpecialKey::OFF are obsolete. Use
    /// TURN_ON_IME session command should be used instead. See b/10216365.
    /// On other platforms, especially on Mac, please note that
    /// client/client.cc still relies on SpecialKey::On for session playback.
    /// We need to fix b/10250883 first.
    /// TODO(team): Unsupport SpecialKey::On and SpecialKey::OFF.
    case on = 2
    case off = 3
    case space = 4
    case enter = 5
    case left = 6
    case right = 7
    case up = 8
    case down = 9
    case escape = 10

    /// Not DELETE because DELETE is reserved in MSVC.
    case del = 11
    case backspace = 12
    case henkan = 13
    case muhenkan = 14

    /// VK_DBE_HIRAGANA(Win), kVK_JIS_Kana(Mac)
    /// The "Katakana Hiragana Romaji" key (w/o modifiers) returns this key code.
    case kana = 15
    case home = 16
    case end = 17
    case tab = 18
    case f1 = 19
    case f2 = 20
    case f3 = 21
    case f4 = 22
    case f5 = 23
    case f6 = 24
    case f7 = 25
    case f8 = 26
    case f9 = 27
    case f10 = 28
    case f11 = 29
    case f12 = 30
    case pageUp = 31
    case pageDown = 32
    case insert = 33
    case f13 = 34
    case f14 = 35
    case f15 = 36
    case f16 = 37
    case f17 = 38
    case f18 = 39
    case f19 = 40
    case f20 = 41
    case f21 = 42
    case f22 = 43
    case f23 = 44
    case f24 = 45

    /// alphanumeric  VK_DBE_ALPHANUMERIC(Win), kVK_JIS_Eisu(Mac)
    case eisu = 46
    case numpad0 = 47
    case numpad1 = 48
    case numpad2 = 49
    case numpad3 = 50
    case numpad4 = 51
    case numpad5 = 52
    case numpad6 = 53
    case numpad7 = 54
    case numpad8 = 55
    case numpad9 = 56

    /// Numpad [*]
    case multiply = 57

    /// Numpad [+]
    case add = 58

    /// Numpad [enter]
    case separator = 59

    /// Numpad [-]
    case subtract = 60

    /// Numpad [.]
    case decimal = 61

    /// Numpad [/]
    case divide = 62

    /// Numpad [=]
    case equals = 63

    /// Meta key event representing any text input.
    case textInput = 64

    /// GUI label is "Hankaku/Zenkaku".
    case hankaku = 65
    case kanji = 66

    /// The "Katakana Hiragana Romaji" key with Shift returns this key code.
    case katakana = 67
    case capsLock = 68

    /// Unsupported keys (e.g. PrtSc, Pause) fall back to UNDEFINED_KEY.
    case undefinedKey = 69

    /// Numpad [,]
    case comma = 70

    /// Numpad [5] without NUMLOCK
    case clear = 71

    /// Left key on virtual (software) keyboard
    case virtualLeft = 72

    /// Right key on virtual (software) keyboard
    case virtualRight = 73

    /// Enter key on virtual (software) keyboard
    case virtualEnter = 74

    /// Up key on virtual (software) keyboard
    case virtualUp = 75

    /// Down key on virtual (software) keyboard
    case virtualDown = 76
    case numSpecialkeys = 77

    init() {
      self = .noSpecialkey
    }

  }

  enum ModifierKey: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case ctrl = 1
    case alt = 2
    case shift = 4
    case keyDown = 8
    case keyUp = 16
    case leftCtrl = 32
    case leftAlt = 64
    case leftShift = 128
    case rightCtrl = 256
    case rightAlt = 512
    case rightShift = 1024
    case caps = 2048

    init() {
      self = .ctrl
    }

  }

  enum InputStyle: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Follow the current input mode (default).
    case followMode = 0

    /// Do not transliterate key_string and use it as-is.
    case asIs = 1

    /// Immediately output key_string on the precomposition mode.
    /// Same with AS_IS on the preedit mode.
    case directInput = 2

    init() {
      self = .followMode
    }

  }

  /// Probable key event, mainly for touch screen.
  /// User's input has ambiguity (e.g. the touch position is merginal)
  /// so this message expresses the probable event.
  struct ProbableKeyEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// message ID is the same as Input message.
    var keyCode: UInt32 {
      get {_keyCode ?? 0}
      set {_keyCode = newValue}
    }
    /// Returns true if `keyCode` has been explicitly set.
    var hasKeyCode: Bool {self._keyCode != nil}
    /// Clears the value of `keyCode`. Subsequent reads from it will return its default value.
    mutating func clearKeyCode() {self._keyCode = nil}

    /// Unprintable key listed above.
    var specialKey: Mozc_Commands_KeyEvent.SpecialKey {
      get {_specialKey ?? .noSpecialkey}
      set {_specialKey = newValue}
    }
    /// Returns true if `specialKey` has been explicitly set.
    var hasSpecialKey: Bool {self._specialKey != nil}
    /// Clears the value of `specialKey`. Subsequent reads from it will return its default value.
    mutating func clearSpecialKey() {self._specialKey = nil}

    /// ModifierKeys
    var modifierKeys: [Mozc_Commands_KeyEvent.ModifierKey] = []

    /// Sum of probabilities must be lesser or equal than 1.
    /// 0<= probability <= 1
    var probability: Double {
      get {_probability ?? 0}
      set {_probability = newValue}
    }
    /// Returns true if `probability` has been explicitly set.
    var hasProbability: Bool {self._probability != nil}
    /// Clears the value of `probability`. Subsequent reads from it will return its default value.
    mutating func clearProbability() {self._probability = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _keyCode: UInt32? = nil
    fileprivate var _specialKey: Mozc_Commands_KeyEvent.SpecialKey? = nil
    fileprivate var _probability: Double? = nil
  }

  init() {}

  fileprivate var _keyCode: UInt32? = nil
  fileprivate var _modifiers: UInt32? = nil
  fileprivate var _specialKey: Mozc_Commands_KeyEvent.SpecialKey? = nil
  fileprivate var _keyString: String? = nil
  fileprivate var _inputStyle: Mozc_Commands_KeyEvent.InputStyle? = nil
  fileprivate var _mode: Mozc_Commands_CompositionMode? = nil
  fileprivate var _activated: Bool? = nil
  fileprivate var _timestampMsec: Int64? = nil
}

struct Mozc_Commands_SessionCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Mozc_Commands_SessionCommand.CommandType {
    get {_type ?? .none}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// Unique number specifying a candidate word.
  /// Note: This value is NOT an index of the candidate window or the candidate
  /// list. This value is a return value of CandidateWord::id().
  var id: Int32 {
    get {_id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// This is used with SWITCH_COMPOSITION_MODE, TURN_ON_IME and TURN_OFF_IME.
  var compositionMode: Mozc_Commands_CompositionMode {
    get {_compositionMode ?? .direct}
    set {_compositionMode = newValue}
  }
  /// Returns true if `compositionMode` has been explicitly set.
  var hasCompositionMode: Bool {self._compositionMode != nil}
  /// Clears the value of `compositionMode`. Subsequent reads from it will return its default value.
  mutating func clearCompositionMode() {self._compositionMode = nil}

  /// Text argument.  This is used by CONVERT_REVERSE at this moment.
  var text: String {
    get {_text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// New cursor position in preedit. Used with MOVE_CURSOR.
  var cursorPosition: UInt32 {
    get {_cursorPosition ?? 0}
    set {_cursorPosition = newValue}
  }
  /// Returns true if `cursorPosition` has been explicitly set.
  var hasCursorPosition: Bool {self._cursorPosition != nil}
  /// Clears the value of `cursorPosition`. Subsequent reads from it will return its default value.
  mutating func clearCursorPosition() {self._cursorPosition = nil}

  /// Assumes that the entries are sorted by the probability.
  /// The most probable event should be at the top.
  var compositionEvents: [Mozc_Commands_SessionCommand.CompositionEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CommandType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Do nothing.
    case none = 0

    /// Revert the session, this is usually similar to type ESC several times.
    case revert = 1

    /// Commit the session, this is usually similar to type Enter.
    /// SUBMIT session command is accepted in any status.
    /// Pre-condition:
    /// - Any states of IME are acceptable.
    /// Post-condition:
    /// - Preedit text becomes empty.
    case submit = 2

    /// Select the specified candidate word by id. This command is
    /// usually used with mouse clicking.
    case selectCandidate = 3

    /// Set the focus to the candidate by id. This is usually used
    /// with mouse dragging or selection of word usage dictionary.
    /// The difference from SELECT_CANDIDATE is that
    /// HIGHLIGHT_CANDIDATE does not close the candidate window
    /// while SELECT_CANDIDATE closes the candidate window.
    case highlightCandidate = 4

    /// Specify the composition mode.  This command should be used with
    /// composition_mode.
    case switchCompositionMode = 5

    /// Return the current status such as composition mode, preedit method, etc.
    case getStatus = 6

    /// This command is typically used for mobile IME's partial conversion,
    /// but currently it is on the way. This description is for current spec.
    ///
    /// This command requires that candidates exist.
    ///
    /// If there is a focused candidate (Conversion or Prediction state),
    /// the candidate matched with the given id in the first segment is
    /// submitted, even though the selected segment is not the first segment
    /// (Important thing is whether focused candidate exists
    /// or not. Focused index itself is ignored).
    /// This behavior should be updated because current cursor position and
    /// position of focused segment affects nothing.
    /// We should fix this non-intuitive behavior. Intuitive behavior might be
    /// submitting segments from first one to focused one (inclusive).
    ///
    /// If no focused candidate (Suggestion, including ZeroQuery suggestion),
    /// first (and only) segment's candidate of which id is equal to id field of
    /// Input message is submitted.
    /// This behavior should be fixed because current cursor position affects
    /// nothing. In future, the characters after the cursor should be kept
    /// as preedit.
    ///
    /// This command's pre- and post- conditions are differenct from
    /// SUBMIT command's. Following conditions will be kept after updating
    /// the behavior.
    /// Pre-condition:
    /// - There should be candidate.
    /// Post-condition:
    /// - No guarantee on preedit text.
    /// TODO(yamaguchi): Update corresponding implementation please.
    case submitCandidate = 7

    /// Perform reverse conversion.
    case convertReverse = 8

    /// Perform Undo.
    case undo = 9

    /// Reset convert history and revert current composition.
    /// This is usually used by moving cursor with mouse clicking.
    case resetContext = 10

    /// Change cursor position in preedit.
    case moveCursor = 11

    /// Specify the input field type.
    case switchInputFieldType = 12

    /// This command is used in only Android.
    /// Works UNDO or rewind HIRAGANA characters based on the state.
    case undoOrRewind = 14

    /// Commit the raw text of the composed string.
    case commitRawText = 19

    /// Call ConvertPrevPage session command to show the previous page of
    /// candidates.
    case convertPrevPage = 20

    /// Call ConvertNextPage session command to show the next page of
    /// candidates.
    case convertNextPage = 21

    /// Make sure IME is turned on. Optionally you can also provide new input
    /// mode in |composition_mode| (but you must not set DIRECT to it).
    /// |composition_mode| is honored even when IME is already turned on.
    case turnOnIme = 22

    /// Make sure IME is turned off. Optionally you can also provide new input
    /// mode in |composition_mode| (but you must not set DIRECT to it). If IME
    /// |composition_mode| is honored even when IME is already turned off.
    case turnOffIme = 23

    /// Delete the candidate specified with |id = 2| from the user history.
    case deleteCandidateFromHistory = 24

    /// Stops key toggling of the composer if its table is a toggle-supported
    /// layout (e.g., 12-key toggle flick.)
    case stopKeyToggling = 25

    /// Update composition with |compoisition_events|.
    /// Unlike SEND_KEY command, this command completely replaces the composition
    /// rather than appending to the existing composition.
    /// The command will be used for supporting handwriting.
    case updateComposition = 26

    /// Explicitly request Next Word Prediction (NWP, zero query suggestion) from
    /// the surrounding text.
    /// Note: This command resets the internal states (history segments) of the
    /// converter.
    case requestNwp = 27

    init() {
      self = .none
    }

  }

  /// Used by UPDATE_COMPOSITION event
  struct CompositionEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var compositionString: String {
      get {_compositionString ?? String()}
      set {_compositionString = newValue}
    }
    /// Returns true if `compositionString` has been explicitly set.
    var hasCompositionString: Bool {self._compositionString != nil}
    /// Clears the value of `compositionString`. Subsequent reads from it will return its default value.
    mutating func clearCompositionString() {self._compositionString = nil}

    /// Sum of probabilities must be lesser or equal than 1.
    /// 0<= probability <= 1
    var probability: Double {
      get {_probability ?? 0}
      set {_probability = newValue}
    }
    /// Returns true if `probability` has been explicitly set.
    var hasProbability: Bool {self._probability != nil}
    /// Clears the value of `probability`. Subsequent reads from it will return its default value.
    mutating func clearProbability() {self._probability = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _compositionString: String? = nil
    fileprivate var _probability: Double? = nil
  }

  init() {}

  fileprivate var _type: Mozc_Commands_SessionCommand.CommandType? = nil
  fileprivate var _id: Int32? = nil
  fileprivate var _compositionMode: Mozc_Commands_CompositionMode? = nil
  fileprivate var _text: String? = nil
  fileprivate var _cursorPosition: UInt32? = nil
}

struct Mozc_Commands_Context: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Former part of surrounding text.
  var precedingText: String {
    get {_precedingText ?? String()}
    set {_precedingText = newValue}
  }
  /// Returns true if `precedingText` has been explicitly set.
  var hasPrecedingText: Bool {self._precedingText != nil}
  /// Clears the value of `precedingText`. Subsequent reads from it will return its default value.
  mutating func clearPrecedingText() {self._precedingText = nil}

  /// Latter part of surrounding text.
  var followingText: String {
    get {_followingText ?? String()}
    set {_followingText = newValue}
  }
  /// Returns true if `followingText` has been explicitly set.
  var hasFollowingText: Bool {self._followingText != nil}
  /// Clears the value of `followingText`. Subsequent reads from it will return its default value.
  mutating func clearFollowingText() {self._followingText = nil}

  /// If this is true, suggestion feature is disabled regardless the
  /// configuration.  If this is false, suggestion feature is followed
  /// by the user's configuration.  If you want to omit interim
  /// suggestions during the key typing, you might want to use
  /// request_suggestion.
  var suppressSuggestion: Bool {
    get {_suppressSuggestion ?? false}
    set {_suppressSuggestion = newValue}
  }
  /// Returns true if `suppressSuggestion` has been explicitly set.
  var hasSuppressSuggestion: Bool {self._suppressSuggestion != nil}
  /// Clears the value of `suppressSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearSuppressSuggestion() {self._suppressSuggestion = nil}

  /// Type of the input field being focused.
  var inputFieldType: Mozc_Commands_Context.InputFieldType {
    get {_inputFieldType ?? .normal}
    set {_inputFieldType = newValue}
  }
  /// Returns true if `inputFieldType` has been explicitly set.
  var hasInputFieldType: Bool {self._inputFieldType != nil}
  /// Clears the value of `inputFieldType`. Subsequent reads from it will return its default value.
  mutating func clearInputFieldType() {self._inputFieldType = nil}

  /// An unique revision ID to specify one specific typing session. A client can
  /// use arbitrary value for this field. The converter is expected to clear its
  /// internal history segments whenever this value is changed. A client should
  /// use the same revision ID whenever the converter should keep it internal
  /// history segments. In order to avoid unexpected history learnings, a client
  /// should update the revision whenever the input focus is changed.
  var revision: Int32 {
    get {_revision ?? 0}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  /// Repeated fields to be used for experimental features.
  var experimentalFeatures: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Input field type.
  /// The types are based on the input types defined in HTML5.
  /// http://dev.w3.org/html5/spec/Overview.html#attr-input-type
  /// Other types are to be added later.
  enum InputFieldType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// No restrictions nor special functions. The IME operates as usual.
    case normal = 1

    /// Password field. Text is hidden after input.
    /// For Android,
    /// In order to make the last character visible to the user,
    /// the IME must not hold more than 2 characters in preedit.
    case password = 2

    /// Telephone number
    case tel = 3

    /// Number
    case number = 4

    init() {
      self = .normal
    }

  }

  init() {}

  fileprivate var _precedingText: String? = nil
  fileprivate var _followingText: String? = nil
  fileprivate var _suppressSuggestion: Bool? = nil
  fileprivate var _inputFieldType: Mozc_Commands_Context.InputFieldType? = nil
  fileprivate var _revision: Int32? = nil
}

/// Clients' capability.
/// Users cannot modify this.
/// The server has to obey this capability.
struct Mozc_Commands_Capability: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var textDeletion: Mozc_Commands_Capability.TextDeletionCapabilityType {
    get {_textDeletion ?? .noTextDeletionCapability}
    set {_textDeletion = newValue}
  }
  /// Returns true if `textDeletion` has been explicitly set.
  var hasTextDeletion: Bool {self._textDeletion != nil}
  /// Clears the value of `textDeletion`. Subsequent reads from it will return its default value.
  mutating func clearTextDeletion() {self._textDeletion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Bit fields to notify what the client can do.
  enum TextDeletionCapabilityType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case noTextDeletionCapability = 0

    /// Can delete preceding text which is adjacent to preedit.
    case deletePrecedingText = 1

    init() {
      self = .noTextDeletionCapability
    }

  }

  init() {}

  fileprivate var _textDeletion: Mozc_Commands_Capability.TextDeletionCapabilityType? = nil
}

/// Next ID: 140
/// Bundles together some Android experiment flags so that they can be easily
/// retrieved throughout the native code.  These flags are generally specific to
/// the decoder, and are made available when the decoder is initialized.
struct Mozc_Commands_DecoderExperimentParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bitmap of enabled variation character types.
  var variationCharacterTypes: UInt32 {
    get {_variationCharacterTypes ?? 0}
    set {_variationCharacterTypes = newValue}
  }
  /// Returns true if `variationCharacterTypes` has been explicitly set.
  var hasVariationCharacterTypes: Bool {self._variationCharacterTypes != nil}
  /// Clears the value of `variationCharacterTypes`. Subsequent reads from it will return its default value.
  mutating func clearVariationCharacterTypes() {self._variationCharacterTypes = nil}

  /// Enables final results reranking against literal results.
  /// If zero, the previous implementation is used.
  var typingCorrectionResultRerankerMode: Int32 {
    get {_typingCorrectionResultRerankerMode ?? 0}
    set {_typingCorrectionResultRerankerMode = newValue}
  }
  /// Returns true if `typingCorrectionResultRerankerMode` has been explicitly set.
  var hasTypingCorrectionResultRerankerMode: Bool {self._typingCorrectionResultRerankerMode != nil}
  /// Clears the value of `typingCorrectionResultRerankerMode`. Subsequent reads from it will return its default value.
  mutating func clearTypingCorrectionResultRerankerMode() {self._typingCorrectionResultRerankerMode = nil}

  /// Promote TC/Literal if w * tc_reranker_score + (1.0 - w) lm_diff > 0.0.
  var typingCorrectionResultRerankerInterpolationWeight: Float {
    get {_typingCorrectionResultRerankerInterpolationWeight ?? 0}
    set {_typingCorrectionResultRerankerInterpolationWeight = newValue}
  }
  /// Returns true if `typingCorrectionResultRerankerInterpolationWeight` has been explicitly set.
  var hasTypingCorrectionResultRerankerInterpolationWeight: Bool {self._typingCorrectionResultRerankerInterpolationWeight != nil}
  /// Clears the value of `typingCorrectionResultRerankerInterpolationWeight`. Subsequent reads from it will return its default value.
  mutating func clearTypingCorrectionResultRerankerInterpolationWeight() {self._typingCorrectionResultRerankerInterpolationWeight = nil}

  /// Runs Literal-at-least second when original_tc_score + w * tc_reranker_score
  /// > 0.0. otherwise, runs literal-on-top.
  var typingCorrectionResultRerankerLiteralOnTopWeight: Float {
    get {_typingCorrectionResultRerankerLiteralOnTopWeight ?? 0}
    set {_typingCorrectionResultRerankerLiteralOnTopWeight = newValue}
  }
  /// Returns true if `typingCorrectionResultRerankerLiteralOnTopWeight` has been explicitly set.
  var hasTypingCorrectionResultRerankerLiteralOnTopWeight: Bool {self._typingCorrectionResultRerankerLiteralOnTopWeight != nil}
  /// Clears the value of `typingCorrectionResultRerankerLiteralOnTopWeight`. Subsequent reads from it will return its default value.
  mutating func clearTypingCorrectionResultRerankerLiteralOnTopWeight() {self._typingCorrectionResultRerankerLiteralOnTopWeight = nil}

  /// Uses the typing correction in user history predictor. The size specifies
  /// the maximum number of typing corrections used for query lookup.
  /// When zero, typing_correction is not used.
  var typingCorrectionApplyUserHistorySize: Int32 {
    get {_typingCorrectionApplyUserHistorySize ?? 0}
    set {_typingCorrectionApplyUserHistorySize = newValue}
  }
  /// Returns true if `typingCorrectionApplyUserHistorySize` has been explicitly set.
  var hasTypingCorrectionApplyUserHistorySize: Bool {self._typingCorrectionApplyUserHistorySize != nil}
  /// Clears the value of `typingCorrectionApplyUserHistorySize`. Subsequent reads from it will return its default value.
  mutating func clearTypingCorrectionApplyUserHistorySize() {self._typingCorrectionApplyUserHistorySize = nil}

  var disableZeroQuerySuffixPrediction: Bool {
    get {_disableZeroQuerySuffixPrediction ?? false}
    set {_disableZeroQuerySuffixPrediction = newValue}
  }
  /// Returns true if `disableZeroQuerySuffixPrediction` has been explicitly set.
  var hasDisableZeroQuerySuffixPrediction: Bool {self._disableZeroQuerySuffixPrediction != nil}
  /// Clears the value of `disableZeroQuerySuffixPrediction`. Subsequent reads from it will return its default value.
  mutating func clearDisableZeroQuerySuffixPrediction() {self._disableZeroQuerySuffixPrediction = nil}

  /// Changes the size of history with character coverage.
  var userHistoryPredictionMaxCharCoverage: Int32 {
    get {_userHistoryPredictionMaxCharCoverage ?? 0}
    set {_userHistoryPredictionMaxCharCoverage = newValue}
  }
  /// Returns true if `userHistoryPredictionMaxCharCoverage` has been explicitly set.
  var hasUserHistoryPredictionMaxCharCoverage: Bool {self._userHistoryPredictionMaxCharCoverage != nil}
  /// Clears the value of `userHistoryPredictionMaxCharCoverage`. Subsequent reads from it will return its default value.
  mutating func clearUserHistoryPredictionMaxCharCoverage() {self._userHistoryPredictionMaxCharCoverage = nil}

  /// Parameter for space-insertion for English compounds
  /// value 0: no insertion. Candidates will be like this.
  /// - "Google"
  /// - "GOOGLE"
  /// - "google"
  /// value 1: expand for all English candidates
  /// This mode adds space-prefixed candidates for three style, like this.
  /// - "Google"
  /// - " Google"
  /// - "GOOGLE"
  /// - " GOOGLE"
  /// - "google"
  /// - " google"
  var englishVariationSpaceInsertionMode: Int32 {
    get {_englishVariationSpaceInsertionMode ?? 0}
    set {_englishVariationSpaceInsertionMode = newValue}
  }
  /// Returns true if `englishVariationSpaceInsertionMode` has been explicitly set.
  var hasEnglishVariationSpaceInsertionMode: Bool {self._englishVariationSpaceInsertionMode != nil}
  /// Clears the value of `englishVariationSpaceInsertionMode`. Subsequent reads from it will return its default value.
  mutating func clearEnglishVariationSpaceInsertionMode() {self._englishVariationSpaceInsertionMode = nil}

  var candidateConsistencyCostMaxDiff: Int32 {
    get {_candidateConsistencyCostMaxDiff ?? 0}
    set {_candidateConsistencyCostMaxDiff = newValue}
  }
  /// Returns true if `candidateConsistencyCostMaxDiff` has been explicitly set.
  var hasCandidateConsistencyCostMaxDiff: Bool {self._candidateConsistencyCostMaxDiff != nil}
  /// Clears the value of `candidateConsistencyCostMaxDiff`. Subsequent reads from it will return its default value.
  mutating func clearCandidateConsistencyCostMaxDiff() {self._candidateConsistencyCostMaxDiff = nil}

  var maxCompositionEventToProcess: Int32 {
    get {_maxCompositionEventToProcess ?? 2}
    set {_maxCompositionEventToProcess = newValue}
  }
  /// Returns true if `maxCompositionEventToProcess` has been explicitly set.
  var hasMaxCompositionEventToProcess: Bool {self._maxCompositionEventToProcess != nil}
  /// Clears the value of `maxCompositionEventToProcess`. Subsequent reads from it will return its default value.
  mutating func clearMaxCompositionEventToProcess() {self._maxCompositionEventToProcess = nil}

  /// Offset to promote Katakana candidates in rewriter.
  /// The promotion will be disabled if the value is negative.
  var katakanaPromotionOffset: Int32 {
    get {_katakanaPromotionOffset ?? 5}
    set {_katakanaPromotionOffset = newValue}
  }
  /// Returns true if `katakanaPromotionOffset` has been explicitly set.
  var hasKatakanaPromotionOffset: Bool {self._katakanaPromotionOffset != nil}
  /// Clears the value of `katakanaPromotionOffset`. Subsequent reads from it will return its default value.
  mutating func clearKatakanaPromotionOffset() {self._katakanaPromotionOffset = nil}

  /// Cost offset for handwriting conversion candidate.
  /// default_value: 10*log(500)
  var handwritingConversionCandidateCostOffset: Int32 {
    get {_handwritingConversionCandidateCostOffset ?? 1151}
    set {_handwritingConversionCandidateCostOffset = newValue}
  }
  /// Returns true if `handwritingConversionCandidateCostOffset` has been explicitly set.
  var hasHandwritingConversionCandidateCostOffset: Bool {self._handwritingConversionCandidateCostOffset != nil}
  /// Clears the value of `handwritingConversionCandidateCostOffset`. Subsequent reads from it will return its default value.
  mutating func clearHandwritingConversionCandidateCostOffset() {self._handwritingConversionCandidateCostOffset = nil}

  /// Threshold for suffix NWP transition cost.
  /// If the transition cost is greater than this value, the candidate will be
  /// filtered.
  /// The candidate will not be filtered if this value is zero.
  var suffixNwpTransitionCostThreshold: Int32 {
    get {_suffixNwpTransitionCostThreshold ?? 0}
    set {_suffixNwpTransitionCostThreshold = newValue}
  }
  /// Returns true if `suffixNwpTransitionCostThreshold` has been explicitly set.
  var hasSuffixNwpTransitionCostThreshold: Bool {self._suffixNwpTransitionCostThreshold != nil}
  /// Clears the value of `suffixNwpTransitionCostThreshold`. Subsequent reads from it will return its default value.
  mutating func clearSuffixNwpTransitionCostThreshold() {self._suffixNwpTransitionCostThreshold = nil}

  /// Stores inner segment boundary in user history cache.
  /// This information is going to be shared with user_segment_rewriter.
  var userHistoryCacheInnerSegmentBoundary: Bool {
    get {_userHistoryCacheInnerSegmentBoundary ?? false}
    set {_userHistoryCacheInnerSegmentBoundary = newValue}
  }
  /// Returns true if `userHistoryCacheInnerSegmentBoundary` has been explicitly set.
  var hasUserHistoryCacheInnerSegmentBoundary: Bool {self._userHistoryCacheInnerSegmentBoundary != nil}
  /// Clears the value of `userHistoryCacheInnerSegmentBoundary`. Subsequent reads from it will return its default value.
  mutating func clearUserHistoryCacheInnerSegmentBoundary() {self._userHistoryCacheInnerSegmentBoundary = nil}

  /// Position of the first symbol rewriter candidate (0-origin).
  var symbolRewriterCandidatePosition: Int32 {
    get {_symbolRewriterCandidatePosition ?? 3}
    set {_symbolRewriterCandidatePosition = newValue}
  }
  /// Returns true if `symbolRewriterCandidatePosition` has been explicitly set.
  var hasSymbolRewriterCandidatePosition: Bool {self._symbolRewriterCandidatePosition != nil}
  /// Clears the value of `symbolRewriterCandidatePosition`. Subsequent reads from it will return its default value.
  mutating func clearSymbolRewriterCandidatePosition() {self._symbolRewriterCandidatePosition = nil}

  /// Number of candidates to be promoted.
  /// For example, if symbol_rewriter_candidate_position == 0, and
  /// symbol_rewriter_promotion_size == 5, the first 5 candidates are symbols.
  var symbolRewriterPromotionSize: Int32 {
    get {_symbolRewriterPromotionSize ?? 15}
    set {_symbolRewriterPromotionSize = newValue}
  }
  /// Returns true if `symbolRewriterPromotionSize` has been explicitly set.
  var hasSymbolRewriterPromotionSize: Bool {self._symbolRewriterPromotionSize != nil}
  /// Clears the value of `symbolRewriterPromotionSize`. Subsequent reads from it will return its default value.
  mutating func clearSymbolRewriterPromotionSize() {self._symbolRewriterPromotionSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VariationCharacterType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case noVariation = 0

    /// Standardized variation sequences for Japanese.
    /// https://unicode.org/Public/UNIDATA/StandardizedVariants.txt
    /// It specifies to use SVS characters instead of CJK compatibility
    /// ideographs for Japanese.
    case svsJapanese = 1

    init() {
      self = .noVariation
    }

  }

  enum BigramNwpFilteringMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Control implementation is used. For example,
    /// - Kanji + Katakana will not be filtered.
    /// - If cost(prefix) > cost(original_entry), the candidate will be filtered.
    /// - The reading of the target candidate should be in the dictionary.
    /// - ,etc
    case `default` = 0

    /// In addition to the default filtering, filter entry if the character
    /// script type does not change from the prefix.
    case filterSameCtype = 1

    /// Filter all bigram candidates.
    case filterAll = 2

    init() {
      self = .default
    }

  }

  init() {}

  fileprivate var _variationCharacterTypes: UInt32? = nil
  fileprivate var _typingCorrectionResultRerankerMode: Int32? = nil
  fileprivate var _typingCorrectionResultRerankerInterpolationWeight: Float? = nil
  fileprivate var _typingCorrectionResultRerankerLiteralOnTopWeight: Float? = nil
  fileprivate var _typingCorrectionApplyUserHistorySize: Int32? = nil
  fileprivate var _disableZeroQuerySuffixPrediction: Bool? = nil
  fileprivate var _userHistoryPredictionMaxCharCoverage: Int32? = nil
  fileprivate var _englishVariationSpaceInsertionMode: Int32? = nil
  fileprivate var _candidateConsistencyCostMaxDiff: Int32? = nil
  fileprivate var _maxCompositionEventToProcess: Int32? = nil
  fileprivate var _katakanaPromotionOffset: Int32? = nil
  fileprivate var _handwritingConversionCandidateCostOffset: Int32? = nil
  fileprivate var _suffixNwpTransitionCostThreshold: Int32? = nil
  fileprivate var _userHistoryCacheInnerSegmentBoundary: Bool? = nil
  fileprivate var _symbolRewriterCandidatePosition: Int32? = nil
  fileprivate var _symbolRewriterPromotionSize: Int32? = nil
}

/// Clients' request to the server.
/// Users cannot modify this.
/// In the future each request may be able to be overwritten by Config.
/// The server does not have to obey this request.
/// Next ID: 25
struct Mozc_Commands_Request: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enable zero query suggestion.
  var zeroQuerySuggestion: Bool {
    get {_storage._zeroQuerySuggestion ?? false}
    set {_uniqueStorage()._zeroQuerySuggestion = newValue}
  }
  /// Returns true if `zeroQuerySuggestion` has been explicitly set.
  var hasZeroQuerySuggestion: Bool {_storage._zeroQuerySuggestion != nil}
  /// Clears the value of `zeroQuerySuggestion`. Subsequent reads from it will return its default value.
  mutating func clearZeroQuerySuggestion() {_uniqueStorage()._zeroQuerySuggestion = nil}

  /// Conversion's candidate includes suggestion, prediction and conversion.
  var mixedConversion: Bool {
    get {_storage._mixedConversion ?? false}
    set {_uniqueStorage()._mixedConversion = newValue}
  }
  /// Returns true if `mixedConversion` has been explicitly set.
  var hasMixedConversion: Bool {_storage._mixedConversion != nil}
  /// Clears the value of `mixedConversion`. Subsequent reads from it will return its default value.
  mutating func clearMixedConversion() {_uniqueStorage()._mixedConversion = nil}

  /// Use special Romanji table.
  var specialRomanjiTable: Mozc_Commands_Request.SpecialRomanjiTable {
    get {_storage._specialRomanjiTable ?? .defaultTable}
    set {_uniqueStorage()._specialRomanjiTable = newValue}
  }
  /// Returns true if `specialRomanjiTable` has been explicitly set.
  var hasSpecialRomanjiTable: Bool {_storage._specialRomanjiTable != nil}
  /// Clears the value of `specialRomanjiTable`. Subsequent reads from it will return its default value.
  mutating func clearSpecialRomanjiTable() {_uniqueStorage()._specialRomanjiTable = nil}

  var spaceOnAlphanumeric: Mozc_Commands_Request.SpaceOnAlphanumeric {
    get {_storage._spaceOnAlphanumeric ?? .spaceOrConvertKeepingComposition}
    set {_uniqueStorage()._spaceOnAlphanumeric = newValue}
  }
  /// Returns true if `spaceOnAlphanumeric` has been explicitly set.
  var hasSpaceOnAlphanumeric: Bool {_storage._spaceOnAlphanumeric != nil}
  /// Clears the value of `spaceOnAlphanumeric`. Subsequent reads from it will return its default value.
  mutating func clearSpaceOnAlphanumeric() {_uniqueStorage()._spaceOnAlphanumeric = nil}

  /// Keyboard name for touch devices.
  /// For example, "TWELVE_KEY_TOGGLE_KANA", "QWERTY_KANA_NUMBER".
  /// It is used to analyze touch event usage stats.
  var keyboardName: String {
    get {_storage._keyboardName ?? String()}
    set {_uniqueStorage()._keyboardName = newValue}
  }
  /// Returns true if `keyboardName` has been explicitly set.
  var hasKeyboardName: Bool {_storage._keyboardName != nil}
  /// Clears the value of `keyboardName`. Subsequent reads from it will return its default value.
  mutating func clearKeyboardName() {_uniqueStorage()._keyboardName = nil}

  /// Enables Composer's input mode auto updating by using surrounding text.
  /// For example, when a composition string is "ad", a carret is at the end,
  /// and a user selects HIRAGANA mode, if the user moves the carret to between
  /// "a" and "d" the mode will be automatically switch to ASCII (temporarily).
  /// See details in the Composer::UpdateInputMode.
  var updateInputModeFromSurroundingText: Bool {
    get {_storage._updateInputModeFromSurroundingText ?? true}
    set {_uniqueStorage()._updateInputModeFromSurroundingText = newValue}
  }
  /// Returns true if `updateInputModeFromSurroundingText` has been explicitly set.
  var hasUpdateInputModeFromSurroundingText: Bool {_storage._updateInputModeFromSurroundingText != nil}
  /// Clears the value of `updateInputModeFromSurroundingText`. Subsequent reads from it will return its default value.
  mutating func clearUpdateInputModeFromSurroundingText() {_uniqueStorage()._updateInputModeFromSurroundingText = nil}

  /// Enables Kana-modifier-insensitive conversion as follows:
  /// 1) Voiced/Semi-voiced kana will be hit by non-modified kana.
  ///    e.g.) "ば" and "ぱ" will be hit by key "は".
  /// 2) Geminate consonant "っ" will be hit by non-modified kana "つ".
  /// 3) Palatalized kana will be hit by non-modified kana.
  ///    e.g.) "ゃ" will be hit by key "や".
  /// Here is an example of the search: "学校" ("がっこう") will be hit
  /// by "かつこう".
  var kanaModifierInsensitiveConversion: Bool {
    get {_storage._kanaModifierInsensitiveConversion ?? false}
    set {_uniqueStorage()._kanaModifierInsensitiveConversion = newValue}
  }
  /// Returns true if `kanaModifierInsensitiveConversion` has been explicitly set.
  var hasKanaModifierInsensitiveConversion: Bool {_storage._kanaModifierInsensitiveConversion != nil}
  /// Clears the value of `kanaModifierInsensitiveConversion`. Subsequent reads from it will return its default value.
  mutating func clearKanaModifierInsensitiveConversion() {_uniqueStorage()._kanaModifierInsensitiveConversion = nil}

  /// Enables Auto partial suggestion (prefix candidates).
  /// For Auto partial suggestion, we can see candidates that match
  /// the prefix of the input reading.
  /// If we commit that candidate, we will show suggestions for remaining part
  /// of key.
  ///
  /// Note: This feature can be enabled only for mobile due to UX design.
  var autoPartialSuggestion: Bool {
    get {_storage._autoPartialSuggestion ?? false}
    set {_uniqueStorage()._autoPartialSuggestion = newValue}
  }
  /// Returns true if `autoPartialSuggestion` has been explicitly set.
  var hasAutoPartialSuggestion: Bool {_storage._autoPartialSuggestion != nil}
  /// Clears the value of `autoPartialSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearAutoPartialSuggestion() {_uniqueStorage()._autoPartialSuggestion = nil}

  /// By default, Emoji rewriter works on conversion mode only.
  var emojiRewriterCapability: Int32 {
    get {_storage._emojiRewriterCapability ?? 1}
    set {_uniqueStorage()._emojiRewriterCapability = newValue}
  }
  /// Returns true if `emojiRewriterCapability` has been explicitly set.
  var hasEmojiRewriterCapability: Bool {_storage._emojiRewriterCapability != nil}
  /// Clears the value of `emojiRewriterCapability`. Subsequent reads from it will return its default value.
  mutating func clearEmojiRewriterCapability() {_uniqueStorage()._emojiRewriterCapability = nil}

  var crossingEdgeBehavior: Mozc_Commands_Request.CrossingEdgeBehavior {
    get {_storage._crossingEdgeBehavior ?? .doNothing}
    set {_uniqueStorage()._crossingEdgeBehavior = newValue}
  }
  /// Returns true if `crossingEdgeBehavior` has been explicitly set.
  var hasCrossingEdgeBehavior: Bool {_storage._crossingEdgeBehavior != nil}
  /// Clears the value of `crossingEdgeBehavior`. Subsequent reads from it will return its default value.
  mutating func clearCrossingEdgeBehavior() {_uniqueStorage()._crossingEdgeBehavior = nil}

  var languageAwareInput: Mozc_Commands_Request.LanguageAwareInputBehavior {
    get {_storage._languageAwareInput ?? .defaultLanguageAwareBehavior}
    set {_uniqueStorage()._languageAwareInput = newValue}
  }
  /// Returns true if `languageAwareInput` has been explicitly set.
  var hasLanguageAwareInput: Bool {_storage._languageAwareInput != nil}
  /// Clears the value of `languageAwareInput`. Subsequent reads from it will return its default value.
  mutating func clearLanguageAwareInput() {_uniqueStorage()._languageAwareInput = nil}

  /// Page size of the candidate list.
  var candidatePageSize: Int32 {
    get {_storage._candidatePageSize ?? 9}
    set {_uniqueStorage()._candidatePageSize = newValue}
  }
  /// Returns true if `candidatePageSize` has been explicitly set.
  var hasCandidatePageSize: Bool {_storage._candidatePageSize != nil}
  /// Clears the value of `candidatePageSize`. Subsequent reads from it will return its default value.
  mutating func clearCandidatePageSize() {_uniqueStorage()._candidatePageSize = nil}

  /// The maximum limit of the candidates size.
  /// If not set, converter doesn't limit the size.
  /// NOTE: Each segment has at least one candidate and meta candidates even if
  ///       this value is set to 0.
  var candidatesSizeLimit: Int32 {
    get {_storage._candidatesSizeLimit ?? 0}
    set {_uniqueStorage()._candidatesSizeLimit = newValue}
  }
  /// Returns true if `candidatesSizeLimit` has been explicitly set.
  var hasCandidatesSizeLimit: Bool {_storage._candidatesSizeLimit != nil}
  /// Clears the value of `candidatesSizeLimit`. Subsequent reads from it will return its default value.
  mutating func clearCandidatesSizeLimit() {_uniqueStorage()._candidatesSizeLimit = nil}

  /// Experimentally changes the decoder's behavior.
  /// This flag is usually populated through the phenotype flags.
  var decoderExperimentParams: Mozc_Commands_DecoderExperimentParams {
    get {_storage._decoderExperimentParams ?? Mozc_Commands_DecoderExperimentParams()}
    set {_uniqueStorage()._decoderExperimentParams = newValue}
  }
  /// Returns true if `decoderExperimentParams` has been explicitly set.
  var hasDecoderExperimentParams: Bool {_storage._decoderExperimentParams != nil}
  /// Clears the value of `decoderExperimentParams`. Subsequent reads from it will return its default value.
  mutating func clearDecoderExperimentParams() {_uniqueStorage()._decoderExperimentParams = nil}

  /// Fills incognito_candidate_words filed of output.
  var fillIncognitoCandidateWords: Bool {
    get {_storage._fillIncognitoCandidateWords ?? false}
    set {_uniqueStorage()._fillIncognitoCandidateWords = newValue}
  }
  /// Returns true if `fillIncognitoCandidateWords` has been explicitly set.
  var hasFillIncognitoCandidateWords: Bool {_storage._fillIncognitoCandidateWords != nil}
  /// Clears the value of `fillIncognitoCandidateWords`. Subsequent reads from it will return its default value.
  mutating func clearFillIncognitoCandidateWords() {_uniqueStorage()._fillIncognitoCandidateWords = nil}

  /// Enables a11y support for candidates.
  /// If this field is set to true, a11y description is set to each candidate.
  var enableA11YDescription: Bool {
    get {_storage._enableA11YDescription ?? false}
    set {_uniqueStorage()._enableA11YDescription = newValue}
  }
  /// Returns true if `enableA11YDescription` has been explicitly set.
  var hasEnableA11YDescription: Bool {_storage._enableA11YDescription != nil}
  /// Clears the value of `enableA11YDescription`. Subsequent reads from it will return its default value.
  mutating func clearEnableA11YDescription() {_uniqueStorage()._enableA11YDescription = nil}

  /// Characters in the union of this list of groups can be contained in
  /// candidates.
  /// This feature is distinct from user preference. Do not make these option
  /// user selectable.
  var additionalRenderableCharacterGroups: [Mozc_Commands_Request.AdditionalRenderableCharacterGroup] {
    get {_storage._additionalRenderableCharacterGroups}
    set {_uniqueStorage()._additionalRenderableCharacterGroups = newValue}
  }

  /// Whether the request is from handwriting. Candidates can be optimized
  /// differently for handwriting.
  /// For example, we support 混ぜ書き conversion ("かん字" → "漢字") for
  /// handwriting.
  var isHandwriting: Bool {
    get {_storage._isHandwriting ?? false}
    set {_uniqueStorage()._isHandwriting = newValue}
  }
  /// Returns true if `isHandwriting` has been explicitly set.
  var hasIsHandwriting: Bool {_storage._isHandwriting != nil}
  /// Clears the value of `isHandwriting`. Subsequent reads from it will return its default value.
  mutating func clearIsHandwriting() {_uniqueStorage()._isHandwriting = nil}

  /// Whether the conversion is performed in incognito mode.
  /// In incognito mode, the conversion is performed without using
  /// user history and user dictionary.
  /// When any of this value and Config::incognito_mode are true,
  /// incognito mode is enabled.
  /// Clients needs to check ConversionRequest::incognito_mode() instead of
  /// this value directly, as the incognito mode can be set in other ways.
  var isIncognitoMode: Bool {
    get {_storage._isIncognitoMode ?? false}
    set {_uniqueStorage()._isIncognitoMode = newValue}
  }
  /// Returns true if `isIncognitoMode` has been explicitly set.
  var hasIsIncognitoMode: Bool {_storage._isIncognitoMode != nil}
  /// Clears the value of `isIncognitoMode`. Subsequent reads from it will return its default value.
  mutating func clearIsIncognitoMode() {_uniqueStorage()._isIncognitoMode = nil}

  var displayValueCapability: Mozc_Commands_Request.DisplayValueCapability {
    get {_storage._displayValueCapability ?? .notSupported}
    set {_uniqueStorage()._displayValueCapability = newValue}
  }
  /// Returns true if `displayValueCapability` has been explicitly set.
  var hasDisplayValueCapability: Bool {_storage._displayValueCapability != nil}
  /// Clears the value of `displayValueCapability`. Subsequent reads from it will return its default value.
  mutating func clearDisplayValueCapability() {_uniqueStorage()._displayValueCapability = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Next ID: 51
  enum SpecialRomanjiTable: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Do not use special table.
    /// Romanji table is selected based on Config.
    case defaultTable = 0

    /// Use special table for 12keys (to hiragana).
    case twelveKeysToHiragana = 10

    /// This is a temporary romaji table that is to be used instead of the
    /// current 12keys-to-hiragana table.
    /// TODO(noriyukit): Replace TWELVE_KEYS_TO_HIRAGANA by this.
    case twelveKeysToHiraganaIntuitive = 10000

    /// Use special table for 12keys (to half-width ascii).
    case twelveKeysToHalfwidthascii = 11

    /// Use special table for flick (to hiragana).
    case flickToHiragana = 13

    /// This is a temporary romaji table that is to be used instead of the
    /// current flick-to-hiragana table.
    /// TODO(noriyukit): Replace FLICK_TO_HIRAGANA by this.
    case flickToHiraganaIntuitive = 10002

    /// Use special table for flick (to half-width ascii).
    case flickToHalfwidthascii = 14

    /// Use special table for flick (to alphabet).
    case flickToHalfwidthasciiIos = 44

    /// Use special table for flick (to number).
    case flickToNumber = 43

    /// Use special table for both toggle and flick (to hiragana).
    case toggleFlickToHiragana = 16

    /// This is a temporary romaji table that is to be used instead of the
    /// current toggle_flick_hiragana table.
    /// TODO(noriyukit): Replace TOGGLE_FLICK_HIRAGANA by this.
    case toggleFlickToHiraganaIntuitive = 10001

    /// Use special table for both toggle and flick (to number).
    case toggleFlickToNumber = 42

    /// Use special table for both toggle and flick (to alphabet).
    case toggleFlickToHalfwidthasciiIos = 45

    /// Use special table for both toggle and flick (to half-width ascii).
    case toggleFlickToHalfwidthascii = 17

    /// Use special table for Qwerty (for Mobile) (to hiragana).
    case qwertyMobileToHiragana = 20

    /// Use special table for Qwerty (for Mobile) (to half-width ascii).
    case qwertyMobileToHalfwidthascii = 22

    /// Use special table for Godan (to hiragana).
    case godanToHiragana = 30

    /// Use special table for Godan (to half-width ascii).
    case godanToHalfwidthascii = 31

    /// Use special table for Notouch (to hiragana).
    case notouchToHiragana = 40

    /// Use special table for Notouch (to half-width ascii).
    case notouchToHalfwidthascii = 41

    /// Use special table for 50keys keyboard.
    case fiftyKeysToHiragana = 46

    init() {
      self = .defaultTable
    }

  }

  enum SpaceOnAlphanumeric: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// The first input is treated as a space, double input is treated
    /// as a conversion.  If a character is input after the first
    /// input, the composition will remain.  For example, "ab<space>dc"
    /// becomes "ab dc" as a single composition.
    case spaceOrConvertKeepingComposition = 0

    /// The first input is treated as a space, double input is treated
    /// as a conversion.  If a character is input after the first
    /// input, the previous composition will be committed.  For
    /// example, "ab<space>dc" results "ab " as a committed string and
    /// "dc" as a composition.
    case spaceOrConvertCommittingComposition = 1

    /// Commit the composition and a space.
    case commit = 2

    init() {
      self = .spaceOrConvertKeepingComposition
    }

  }

  /// For emoji rewriter, it is necessary to control when the rewriter runs
  /// based on the clients. The following bit set is sync'ed to
  /// RewriterInterface::CapabilityType (see rewriter_interface.h, too),
  /// so that clients can fill the value.
  enum RewriterCapability: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case notAvailable = 0
    case conversion = 1
    case prediction = 2
    case suggestion = 4

    /// CONVERSION | PREDICTION | SUGGESTION.
    case all = 7

    init() {
      self = .notAvailable
    }

  }

  /// Controls the behavior when a user types the left/right key at the edge
  /// of the preedit string (in more precise, the left key at the beginning
  /// of the preedit string, or the right key at the end).
  enum CrossingEdgeBehavior: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// This is the default behavior. The cursor movement at the edge
    /// will make nothing, i.e., keeping the current cursor position (at the
    /// edge), consume the key event.
    case doNothing = 0

    /// This is the behavior, especially designed for alphabet keyboards on
    /// mobile devices. Assuming the following text:
    ///   XXXXabcde|YYYYY
    /// where XXXX is preceding text, abcde is composing text, YYYYY is
    /// following text and '|' is the caret, when a user sends "RIGHT"
    /// cursor key, we'd like to commit the abcde and move the caret to right.
    /// So the user will get:
    ///   XXXXabcdeY|YYYY
    /// Here, what we need is committing the "abcde" with the appropriate
    /// caret position. (Note that we need to handle the left cursor key, too).
    /// Also, we should *NOT* consume the key, so that the key event will be
    /// handled appropriately by the target application.
    case commitWithoutConsuming = 1

    init() {
      self = .doNothing
    }

  }

  /// Controls the behavior of language aware input.  Language aware input
  /// guesses the actual language regardless the input mode.  For example,
  /// if user type "てｓｔ" it will be treated as "test".
  enum LanguageAwareInputBehavior: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Performs the default behavior considering the platform and channel.
    case defaultLanguageAwareBehavior = 0

    /// Does not perform this functionarity.
    case noLanguageAwareInput = 1

    /// Adds a language aware candidate to the suggestion.
    case languageAwareSuggestion = 2

    init() {
      self = .defaultLanguageAwareBehavior
    }

  }

  /// Additional Character Group represents certain group of characters, that can
  /// be additionaly requested from the client side, based on font-availability
  /// information.
  ///
  /// This enum is not intended to be used for user preference. 'Additional'
  /// cases can change as time advances. For example, when KANA_SUPPLEMENT_6_0
  /// becomes enough available among environments, this option becomes default
  /// and the case will be removed.
  ///
  /// WARNING: Although cases are mutually exclusive now, they are not
  /// necessarily mutually exclusive. However, the current implementation in
  /// NormalizationRewriter assumes they are mutually exclusive.
  /// LINT.IfChange
  /// Next ID: 15
  enum AdditionalRenderableCharacterGroup: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Do not use this case. This case is reserved for future usage.
    /// Because 0th element in enum is used as default value, in order to prevend
    /// having unexpected additional group, this case represents empty set of
    /// characters.
    case empty = 0

    /// Additional Hiragana, Katakana, and Hentaigana.
    ///
    /// It only contains KATAKANA / HIRAGANA LETTER ARCHAIC YE (U+1B000 and
    /// U+1B001) since Unicode 6.0. Some fonts including M+ fonts only support
    /// this letter.
    case kanaSupplement60 = 2

    /// It contains 285 Hentaigana characters supported in KANA_SUPPLEMENT and
    /// KANA_EXTENDED_A (U+1B002 ~ U+1B11E) since Unicode 10.0.
    case kanaSupplementAndKanaExtendedA100 = 3

    /// It contains four archaic hiraganas/katakanas (U+1B11F ~ U+1B122) since
    /// Unicode 14.0.
    case kanaExtendedA140 = 4

    /// Additional Emoji
    /// Emoji in enum can be removed and become default several years passed
    /// after the introduction. Emoji 12.1, released October 2019
    case emoji121 = 5

    /// Emoji 13.0, released March 2020
    case emoji130 = 6

    /// Emoji 13.1, released September 2020
    case emoji131 = 7

    /// Emoji 14.0, released September 2021
    case emoji140 = 8

    /// Emoji 15.0, released September 2022
    case emoji150 = 9

    /// Emoji 15.1, released September 2023
    case emoji151 = 12

    /// Emoji 16.0, released September 2024
    case emoji160 = 13

    /// Emoji 17.0, released Octorber 2025
    case emoji170 = 14

    /// Additional Hieroglyphs (U+13000 ~ U+1342E)
    /// Unicode 5.2, released October 2009
    case egyptianHieroglyph52 = 10

    /// IVS characters in Adobe-Japan1 (U+E0100 ~ U+E010E)
    case ivsCharacter = 11

    init() {
      self = .empty
    }

  }

  /// Whether the client can accept display_value attribute.
  enum DisplayValueCapability: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case notSupported = 0
    case plainText = 1

    init() {
      self = .notSupported
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Note there is another ApplicationInfo inside RendererCommand.
/// Since Input is not using nested message, define ApplicationInfo here.
struct Mozc_Commands_ApplicationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var processID: UInt32 {
    get {_processID ?? 0}
    set {_processID = newValue}
  }
  /// Returns true if `processID` has been explicitly set.
  var hasProcessID: Bool {self._processID != nil}
  /// Clears the value of `processID`. Subsequent reads from it will return its default value.
  mutating func clearProcessID() {self._processID = nil}

  var threadID: UInt32 {
    get {_threadID ?? 0}
    set {_threadID = newValue}
  }
  /// Returns true if `threadID` has been explicitly set.
  var hasThreadID: Bool {self._threadID != nil}
  /// Clears the value of `threadID`. Subsequent reads from it will return its default value.
  mutating func clearThreadID() {self._threadID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _processID: UInt32? = nil
  fileprivate var _threadID: UInt32? = nil
}

struct Mozc_Commands_Input: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Mozc_Commands_Input.CommandType {
    get {_storage._type ?? .none}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {_storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  /// Session ID created by CREATE_SESSION.
  var id: UInt64 {
    get {_storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {_storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// Key combinations used for SEND_KEY or TEST_SEND_KEY.
  var key: Mozc_Commands_KeyEvent {
    get {_storage._key ?? Mozc_Commands_KeyEvent()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {_storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Command sent to the session layer used with SEND_COMMAND.
  var command: Mozc_Commands_SessionCommand {
    get {_storage._command ?? Mozc_Commands_SessionCommand()}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {_storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  /// Input config
  var config: Mozc_Config_Config {
    get {_storage._config ?? Mozc_Config_Config()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {_storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  /// Context data
  var context: Mozc_Commands_Context {
    get {_storage._context ?? Mozc_Commands_Context()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {_storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {_uniqueStorage()._context = nil}

  /// Client capability
  var capability: Mozc_Commands_Capability {
    get {_storage._capability ?? Mozc_Commands_Capability()}
    set {_uniqueStorage()._capability = newValue}
  }
  /// Returns true if `capability` has been explicitly set.
  var hasCapability: Bool {_storage._capability != nil}
  /// Clears the value of `capability`. Subsequent reads from it will return its default value.
  mutating func clearCapability() {_uniqueStorage()._capability = nil}

  /// Application information, like process id.
  /// Server may be able to change the behavior by seeing the
  /// the program name.
  var applicationInfo: Mozc_Commands_ApplicationInfo {
    get {_storage._applicationInfo ?? Mozc_Commands_ApplicationInfo()}
    set {_uniqueStorage()._applicationInfo = newValue}
  }
  /// Returns true if `applicationInfo` has been explicitly set.
  var hasApplicationInfo: Bool {_storage._applicationInfo != nil}
  /// Clears the value of `applicationInfo`. Subsequent reads from it will return its default value.
  mutating func clearApplicationInfo() {_uniqueStorage()._applicationInfo = nil}

  /// Client request
  var request: Mozc_Commands_Request {
    get {_storage._request ?? Mozc_Commands_Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {_storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var touchEvents: [Mozc_Commands_Input.TouchEvent] {
    get {_storage._touchEvents}
    set {_uniqueStorage()._touchEvents = newValue}
  }

  var userDictionaryImportData: Mozc_UserDictionary_UserDictionaryImportData {
    get {_storage._userDictionaryImportData ?? Mozc_UserDictionary_UserDictionaryImportData()}
    set {_uniqueStorage()._userDictionaryImportData = newValue}
  }
  /// Returns true if `userDictionaryImportData` has been explicitly set.
  var hasUserDictionaryImportData: Bool {_storage._userDictionaryImportData != nil}
  /// Clears the value of `userDictionaryImportData`. Subsequent reads from it will return its default value.
  mutating func clearUserDictionaryImportData() {_uniqueStorage()._userDictionaryImportData = nil}

  /// A flag to control if the server should return suggest-results or not.
  /// If this is set to false, regardless of other configurations,
  /// the server won't return suggestion results.
  /// This is set to true by default.
  /// Note that even if this flag is set to false, when a suggestion is shown
  /// in the previous phase, it is possible from the client to submit it.
  /// This works only for suggestions for the key insertion, but not for
  /// others commands, such as predictions or conversions.
  /// This flag is used for the performance improvement in terms of the
  /// latency.  If you want to suppress the suggestions for the UX improment,
  /// you may want to use suppress_suggestion in the Context message.
  var requestSuggestion: Bool {
    get {_storage._requestSuggestion ?? true}
    set {_uniqueStorage()._requestSuggestion = newValue}
  }
  /// Returns true if `requestSuggestion` has been explicitly set.
  var hasRequestSuggestion: Bool {_storage._requestSuggestion != nil}
  /// Clears the value of `requestSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearRequestSuggestion() {_uniqueStorage()._requestSuggestion = nil}

  var engineReloadRequest: Mozc_EngineReloadRequest {
    get {_storage._engineReloadRequest ?? Mozc_EngineReloadRequest()}
    set {_uniqueStorage()._engineReloadRequest = newValue}
  }
  /// Returns true if `engineReloadRequest` has been explicitly set.
  var hasEngineReloadRequest: Bool {_storage._engineReloadRequest != nil}
  /// Clears the value of `engineReloadRequest`. Subsequent reads from it will return its default value.
  mutating func clearEngineReloadRequest() {_uniqueStorage()._engineReloadRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CommandType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case createSession = 1
    case deleteSession = 2
    case sendKey = 3

    /// Check only if the key event will be consumed.  This command is
    /// for TSF on Windows.  You do not need to use this command, if it
    /// is not necessary.
    case testSendKey = 4

    /// Evaluate the command specified by SessionCommand.  The output
    /// format should be the same with an output of a SEND_KEY command.
    case sendCommand = 5

    /// Config accessors.
    case getConfig = 6
    case setConfig = 7

    /// Set client's request
    case setRequest = 17

    /// sync dictionary/history data to local file
    case syncData = 8

    /// shutdowon server safely
    case shutdown = 9

    /// reload mutable data (like config, user-dic, history)
    case reload = 10

    /// realod mutable data and wait for finish
    /// Note: Reloading of user dictionary data is async so that
    /// it will not block the typing.
    /// This command wait for the reloader.
    case reloadAndWait = 15

    /// clear user history data
    case clearUserHistory = 11

    /// clear user prediction data
    case clearUserPrediction = 12

    /// clear unused prediction
    case clearUnusedUserPrediction = 16

    /// clean up sessions
    /// shutdwon if session is empty and
    /// mozc_server is launched with timeout mode
    case cleanup = 13

    /// no operation
    /// can be used for pinging the server
    case noOperation = 14

    /// Send an engine_reload_request (ID: 15) to reload the engine.
    case sendEngineReloadRequest = 27

    /// Sends reload supplemental model
    case reloadSupplementalModel = 30
    case getServerVersion = 19

    /// Import user dictionary from client.
    case importUserDictionary = 31

    /// Number of commands.
    /// When new command is added, the command should use below number
    /// and NUM_OF_COMMANDS should be incremented.
    case numOfCommands = 32

    init() {
      self = .none
    }

  }

  enum TouchAction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case touchDown = 1
    case touchMove = 2
    case touchUp = 3

    init() {
      self = .touchDown
    }

  }

  struct TouchPosition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var action: Mozc_Commands_Input.TouchAction {
      get {_action ?? .touchDown}
      set {_action = newValue}
    }
    /// Returns true if `action` has been explicitly set.
    var hasAction: Bool {self._action != nil}
    /// Clears the value of `action`. Subsequent reads from it will return its default value.
    mutating func clearAction() {self._action = nil}

    /// x, y potision: keyboard left-top is (0, 0), right-bottom is (1, 1).
    var x: Float {
      get {_x ?? 0}
      set {_x = newValue}
    }
    /// Returns true if `x` has been explicitly set.
    var hasX: Bool {self._x != nil}
    /// Clears the value of `x`. Subsequent reads from it will return its default value.
    mutating func clearX() {self._x = nil}

    var y: Float {
      get {_y ?? 0}
      set {_y = newValue}
    }
    /// Returns true if `y` has been explicitly set.
    var hasY: Bool {self._y != nil}
    /// Clears the value of `y`. Subsequent reads from it will return its default value.
    mutating func clearY() {self._y = nil}

    /// timestamp (in ms) is set to zero when the touch event starts.
    var timestamp: Int64 {
      get {_timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _action: Mozc_Commands_Input.TouchAction? = nil
    fileprivate var _x: Float? = nil
    fileprivate var _y: Float? = nil
    fileprivate var _timestamp: Int64? = nil
  }

  /// TouchEvent contains source_id and stroke.
  /// Touch_events contain all key touch event.
  /// Statistical information are collected for each source_id
  /// by SessionUsageObserver.
  struct TouchEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// source_id specifies the user action such as "X button pressed".
    /// It must be unique within the same keyboard_name,
    /// which is set in Request message.
    var sourceID: UInt32 {
      get {_sourceID ?? 0}
      set {_sourceID = newValue}
    }
    /// Returns true if `sourceID` has been explicitly set.
    var hasSourceID: Bool {self._sourceID != nil}
    /// Clears the value of `sourceID`. Subsequent reads from it will return its default value.
    mutating func clearSourceID() {self._sourceID = nil}

    var stroke: [Mozc_Commands_Input.TouchPosition] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sourceID: UInt32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Detailed information of Result.
struct Mozc_Commands_ResultToken: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `value` and `key` represents Segment.Candidate. If the candidante has
  /// functional values, they are stored as a sepalate ResultToken.
  /// e.g. A candidate of {value="今日は", content_value="今日"} results
  /// two ResultToken of {value="今日"} and {value="は"}.
  var value: String {
    get {_value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var key: String {
    get {_key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// `lid` and `rid` are copied from Segment.Candidate. -1 is used as a unknown
  /// POS. e.g. A candidate of {value="朝は", content_value="朝", lid=2, rid=3}
  /// results two ResultToken of {value="朝", lid=2, rid=-1} and
  /// {value="は", lid=-1, rid=3}.
  var lid: Int32 {
    get {_lid ?? -1}
    set {_lid = newValue}
  }
  /// Returns true if `lid` has been explicitly set.
  var hasLid: Bool {self._lid != nil}
  /// Clears the value of `lid`. Subsequent reads from it will return its default value.
  mutating func clearLid() {self._lid = nil}

  var rid: Int32 {
    get {_rid ?? -1}
    set {_rid = newValue}
  }
  /// Returns true if `rid` has been explicitly set.
  var hasRid: Bool {self._rid != nil}
  /// Clears the value of `rid`. Subsequent reads from it will return its default value.
  mutating func clearRid() {self._rid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: String? = nil
  fileprivate var _key: String? = nil
  fileprivate var _lid: Int32? = nil
  fileprivate var _rid: Int32? = nil
}

/// Result contains data to be submitted to the host application by the
/// ime client.
struct Mozc_Commands_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Mozc_Commands_Result.ResultType {
    get {_type ?? .none}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  /// The result of conversion.
  var value: String {
    get {_value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  /// Source of the value.  It is almost always the reading of the value.
  var key: String {
    get {_key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// The caret position after the result submission.
  /// "0" means the end of the result, and a positive value means moving forward
  /// and a negative value backward.
  /// e.g.) "-s", where s is the length of value, means the caret position
  /// after the committing should be the beginning of the committed value.
  var cursorOffset: Int32 {
    get {_cursorOffset ?? 0}
    set {_cursorOffset = newValue}
  }
  /// Returns true if `cursorOffset` has been explicitly set.
  var hasCursorOffset: Bool {self._cursorOffset != nil}
  /// Clears the value of `cursorOffset`. Subsequent reads from it will return its default value.
  mutating func clearCursorOffset() {self._cursorOffset = nil}

  /// Additional information propagated from the internal status.
  var tokens: [Mozc_Commands_ResultToken] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ResultType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case string = 1

    init() {
      self = .none
    }

  }

  init() {}

  fileprivate var _type: Mozc_Commands_Result.ResultType? = nil
  fileprivate var _value: String? = nil
  fileprivate var _key: String? = nil
  fileprivate var _cursorOffset: Int32? = nil
}

/// Preedit represents a composition data, which is rendered on the
/// host application by the ime client.  On Japanese IME, the both
/// Preedit and Conversion statuses are represented by this message.
struct Mozc_Commands_Preedit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cursor: UInt32 {
    get {_cursor ?? 0}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  var hasCursor: Bool {self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  mutating func clearCursor() {self._cursor = nil}

  var segment: [Mozc_Commands_Preedit.Segment] = []

  /// The position of the first segment whose annotation is 'HIGHLIGHT'. Not set
  /// if there are no such segments.
  var highlightedPosition: UInt32 {
    get {_highlightedPosition ?? 0}
    set {_highlightedPosition = newValue}
  }
  /// Returns true if `highlightedPosition` has been explicitly set.
  var hasHighlightedPosition: Bool {self._highlightedPosition != nil}
  /// Clears the value of `highlightedPosition`. Subsequent reads from it will return its default value.
  mutating func clearHighlightedPosition() {self._highlightedPosition = nil}

  /// This flag is set to true if the character at the cursor position
  /// is in toggleable state.  For example, when the table is
  /// TOGGLE_FLICK_TO_HIRAGANA and key event '1' is received
  /// repeatedly, the preedit toggles like あ -> い -> う -> ....  This
  /// flag is true during this cycle.  This state is reset when user
  /// types another key or SessionCommand::STOP_KEY_TOGGLING is
  /// received.
  var isToggleable: Bool {
    get {_isToggleable ?? false}
    set {_isToggleable = newValue}
  }
  /// Returns true if `isToggleable` has been explicitly set.
  var hasIsToggleable: Bool {self._isToggleable != nil}
  /// Clears the value of `isToggleable`. Subsequent reads from it will return its default value.
  mutating func clearIsToggleable() {self._isToggleable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The string data of Preedit is separated into Segment messages
  /// presenting the ime server's status.  On Preedit status of
  /// Japanese IME, there are up to three segments; left side chars of
  /// cursor, forcused char, right side chars of cursor.  On Conversion
  /// status of Japanese IME, the messages literally represent the
  /// segments of the conversion.
  struct Segment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var annotation: Mozc_Commands_Preedit.Segment.Annotation {
      get {_annotation ?? .none}
      set {_annotation = newValue}
    }
    /// Returns true if `annotation` has been explicitly set.
    var hasAnnotation: Bool {self._annotation != nil}
    /// Clears the value of `annotation`. Subsequent reads from it will return its default value.
    mutating func clearAnnotation() {self._annotation = nil}

    var value: String {
      get {_value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    /// The length of value in characters.  This is NOT a number in
    /// bytes or logical character units.  So, the length of "abc" and
    /// "あいう" should be 3, "ヴ" should be 1 and "ｳﾞ" and "う゛"
    /// should be 2.
    var valueLength: UInt32 {
      get {_valueLength ?? 0}
      set {_valueLength = newValue}
    }
    /// Returns true if `valueLength` has been explicitly set.
    var hasValueLength: Bool {self._valueLength != nil}
    /// Clears the value of `valueLength`. Subsequent reads from it will return its default value.
    mutating func clearValueLength() {self._valueLength = nil}

    /// Source of the value.  It is almost always the reading of the value.
    var key: String {
      get {_key ?? String()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Annotation: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case none = 0
      case underline = 1
      case highlight = 2

      init() {
        self = .none
      }

    }

    init() {}

    fileprivate var _annotation: Mozc_Commands_Preedit.Segment.Annotation? = nil
    fileprivate var _value: String? = nil
    fileprivate var _valueLength: UInt32? = nil
    fileprivate var _key: String? = nil
  }

  init() {}

  fileprivate var _cursor: UInt32? = nil
  fileprivate var _highlightedPosition: UInt32? = nil
  fileprivate var _isToggleable: Bool? = nil
}

struct Mozc_Commands_Status: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether IME is ON or OFF
  var activated: Bool {
    get {_activated ?? false}
    set {_activated = newValue}
  }
  /// Returns true if `activated` has been explicitly set.
  var hasActivated: Bool {self._activated != nil}
  /// Clears the value of `activated`. Subsequent reads from it will return its default value.
  mutating func clearActivated() {self._activated = nil}

  /// Visible composition mode when IME is activated. This mode may come from a
  /// temporary composition mode. See |comeback_mode|.
  /// TODO(yukawa): Rename this field to "visible_mode".
  var mode: Mozc_Commands_CompositionMode {
    get {_mode ?? .direct}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  /// True composition mode that is suitable for system global and permanent
  /// composition mode. When a temporary composition mode exists,
  /// |comeback_mode| can be different from |mode|.
  /// TODO(yukawa): Use more appropriate name.
  var comebackMode: Mozc_Commands_CompositionMode {
    get {_comebackMode ?? .direct}
    set {_comebackMode = newValue}
  }
  /// Returns true if `comebackMode` has been explicitly set.
  var hasComebackMode: Bool {self._comebackMode != nil}
  /// Clears the value of `comebackMode`. Subsequent reads from it will return its default value.
  mutating func clearComebackMode() {self._comebackMode = nil}

  /// Whether Undo operation is available.
  /// The client may enable/disable the Undo key based on this value.
  var undoAvailable: Bool {
    get {_undoAvailable ?? false}
    set {_undoAvailable = newValue}
  }
  /// Returns true if `undoAvailable` has been explicitly set.
  var hasUndoAvailable: Bool {self._undoAvailable != nil}
  /// Clears the value of `undoAvailable`. Subsequent reads from it will return its default value.
  mutating func clearUndoAvailable() {self._undoAvailable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _activated: Bool? = nil
  fileprivate var _mode: Mozc_Commands_CompositionMode? = nil
  fileprivate var _comebackMode: Mozc_Commands_CompositionMode? = nil
  fileprivate var _undoAvailable: Bool? = nil
}

/// This message contains which characters are to be deleted by client.
/// E.g. if current composition and surrounding text are
///     "この感じは[漢字は]" ("漢字は" is the composition)
/// and we send DeletionRange with offset == -3 and length == 3, then they will
/// be rendered like:
///     "この[漢字は]"
struct Mozc_Commands_DeletionRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Offset of start of the deletion range.
  /// Right now,
  /// - Only nagative value is expected.
  ///     In this case, the offset is counted from the beginning of the
  ///     composition (see the message comment right above).
  /// - Positive or 0 value is not sent.
  ///     But not forbidden.
  ///     Though its expectation is not decided yet,
  ///     the client implementation should be prepared (at least, don't crash).
  var offset: Int32 {
    get {_offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  /// Length of the range.
  /// Right now offset==abs(length) is expected.
  /// The expectation where the above condition doesn't meet
  /// is not defined yet.
  /// This may be defined in future (when positive offset becomes
  /// supported?).
  var length: Int32 {
    get {_length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offset: Int32? = nil
  fileprivate var _length: Int32? = nil
}

/// Next ID: 27
struct Mozc_Commands_Output: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {_storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {_storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// This variable is going to be obsolete. Please use status(13) instead.
  var mode: Mozc_Commands_CompositionMode {
    get {_storage._mode ?? .direct}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {_storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var consumed: Bool {
    get {_storage._consumed ?? false}
    set {_uniqueStorage()._consumed = newValue}
  }
  /// Returns true if `consumed` has been explicitly set.
  var hasConsumed: Bool {_storage._consumed != nil}
  /// Clears the value of `consumed`. Subsequent reads from it will return its default value.
  mutating func clearConsumed() {_uniqueStorage()._consumed = nil}

  var result: Mozc_Commands_Result {
    get {_storage._result ?? Mozc_Commands_Result()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {_storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  var preedit: Mozc_Commands_Preedit {
    get {_storage._preedit ?? Mozc_Commands_Preedit()}
    set {_uniqueStorage()._preedit = newValue}
  }
  /// Returns true if `preedit` has been explicitly set.
  var hasPreedit: Bool {_storage._preedit != nil}
  /// Clears the value of `preedit`. Subsequent reads from it will return its default value.
  mutating func clearPreedit() {_uniqueStorage()._preedit = nil}

  var candidateWindow: Mozc_Commands_CandidateWindow {
    get {_storage._candidateWindow ?? Mozc_Commands_CandidateWindow()}
    set {_uniqueStorage()._candidateWindow = newValue}
  }
  /// Returns true if `candidateWindow` has been explicitly set.
  var hasCandidateWindow: Bool {_storage._candidateWindow != nil}
  /// Clears the value of `candidateWindow`. Subsequent reads from it will return its default value.
  mutating func clearCandidateWindow() {_uniqueStorage()._candidateWindow = nil}

  var key: Mozc_Commands_KeyEvent {
    get {_storage._key ?? Mozc_Commands_KeyEvent()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {_storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  /// when URL is non empty, UI can open the page with a browser,
  /// after finishing the all rendering part.
  /// We are using this feature for bug-report system.
  var url: String {
    get {_storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {_storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  /// Output config
  var config: Mozc_Config_Config {
    get {_storage._config ?? Mozc_Config_Config()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {_storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {_uniqueStorage()._config = nil}

  var preeditMethod: Mozc_Commands_Output.PreeditMethod {
    get {_storage._preeditMethod ?? .ascii}
    set {_uniqueStorage()._preeditMethod = newValue}
  }
  /// Returns true if `preeditMethod` has been explicitly set.
  var hasPreeditMethod: Bool {_storage._preeditMethod != nil}
  /// Clears the value of `preeditMethod`. Subsequent reads from it will return its default value.
  mutating func clearPreeditMethod() {_uniqueStorage()._preeditMethod = nil}

  var errorCode: Mozc_Commands_Output.ErrorCode {
    get {_storage._errorCode ?? .sessionSuccess}
    set {_uniqueStorage()._errorCode = newValue}
  }
  /// Returns true if `errorCode` has been explicitly set.
  var hasErrorCode: Bool {_storage._errorCode != nil}
  /// Clears the value of `errorCode`. Subsequent reads from it will return its default value.
  mutating func clearErrorCode() {_uniqueStorage()._errorCode = nil}

  /// The current IME status.
  var status: Mozc_Commands_Status {
    get {_storage._status ?? Mozc_Commands_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {_storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// All flatten candidate words stored in 1D array.  This value is
  /// filled only when the content is changed.
  var allCandidateWords: Mozc_Commands_CandidateList {
    get {_storage._allCandidateWords ?? Mozc_Commands_CandidateList()}
    set {_uniqueStorage()._allCandidateWords = newValue}
  }
  /// Returns true if `allCandidateWords` has been explicitly set.
  var hasAllCandidateWords: Bool {_storage._allCandidateWords != nil}
  /// Clears the value of `allCandidateWords`. Subsequent reads from it will return its default value.
  mutating func clearAllCandidateWords() {_uniqueStorage()._allCandidateWords = nil}

  /// Range of characters to be deleted by client.
  var deletionRange: Mozc_Commands_DeletionRange {
    get {_storage._deletionRange ?? Mozc_Commands_DeletionRange()}
    set {_uniqueStorage()._deletionRange = newValue}
  }
  /// Returns true if `deletionRange` has been explicitly set.
  var hasDeletionRange: Bool {_storage._deletionRange != nil}
  /// Clears the value of `deletionRange`. Subsequent reads from it will return its default value.
  mutating func clearDeletionRange() {_uniqueStorage()._deletionRange = nil}

  var launchToolMode: Mozc_Commands_Output.ToolMode {
    get {_storage._launchToolMode ?? .noTool}
    set {_uniqueStorage()._launchToolMode = newValue}
  }
  /// Returns true if `launchToolMode` has been explicitly set.
  var hasLaunchToolMode: Bool {_storage._launchToolMode != nil}
  /// Clears the value of `launchToolMode`. Subsequent reads from it will return its default value.
  mutating func clearLaunchToolMode() {_uniqueStorage()._launchToolMode = nil}

  var callback: Mozc_Commands_Output.Callback {
    get {_storage._callback ?? Mozc_Commands_Output.Callback()}
    set {_uniqueStorage()._callback = newValue}
  }
  /// Returns true if `callback` has been explicitly set.
  var hasCallback: Bool {_storage._callback != nil}
  /// Clears the value of `callback`. Subsequent reads from it will return its default value.
  mutating func clearCallback() {_uniqueStorage()._callback = nil}

  var engineReloadResponse: Mozc_EngineReloadResponse {
    get {_storage._engineReloadResponse ?? Mozc_EngineReloadResponse()}
    set {_uniqueStorage()._engineReloadResponse = newValue}
  }
  /// Returns true if `engineReloadResponse` has been explicitly set.
  var hasEngineReloadResponse: Bool {_storage._engineReloadResponse != nil}
  /// Clears the value of `engineReloadResponse`. Subsequent reads from it will return its default value.
  mutating func clearEngineReloadResponse() {_uniqueStorage()._engineReloadResponse = nil}

  /// For debug. Candidate words removed throuth the conversion process.
  var removedCandidateWordsForDebug: Mozc_Commands_CandidateList {
    get {_storage._removedCandidateWordsForDebug ?? Mozc_Commands_CandidateList()}
    set {_uniqueStorage()._removedCandidateWordsForDebug = newValue}
  }
  /// Returns true if `removedCandidateWordsForDebug` has been explicitly set.
  var hasRemovedCandidateWordsForDebug: Bool {_storage._removedCandidateWordsForDebug != nil}
  /// Clears the value of `removedCandidateWordsForDebug`. Subsequent reads from it will return its default value.
  mutating func clearRemovedCandidateWordsForDebug() {_uniqueStorage()._removedCandidateWordsForDebug = nil}

  /// Candidate words stored in 1D array. The field should be filled without
  /// using any personal data.
  var incognitoCandidateWords: Mozc_Commands_CandidateList {
    get {_storage._incognitoCandidateWords ?? Mozc_Commands_CandidateList()}
    set {_uniqueStorage()._incognitoCandidateWords = newValue}
  }
  /// Returns true if `incognitoCandidateWords` has been explicitly set.
  var hasIncognitoCandidateWords: Bool {_storage._incognitoCandidateWords != nil}
  /// Clears the value of `incognitoCandidateWords`. Subsequent reads from it will return its default value.
  mutating func clearIncognitoCandidateWords() {_uniqueStorage()._incognitoCandidateWords = nil}

  var serverVersion: Mozc_Commands_Output.VersionInfo {
    get {_storage._serverVersion ?? Mozc_Commands_Output.VersionInfo()}
    set {_uniqueStorage()._serverVersion = newValue}
  }
  /// Returns true if `serverVersion` has been explicitly set.
  var hasServerVersion: Bool {_storage._serverVersion != nil}
  /// Clears the value of `serverVersion`. Subsequent reads from it will return its default value.
  mutating func clearServerVersion() {_uniqueStorage()._serverVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// PreeditMethod: this is the default input mode of the session.
  /// If the user's config is "kana-input", it returns KANA.  Only
  /// CreateSession response will have this field.
  enum PreeditMethod: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case ascii = 0
    case kana = 1

    init() {
      self = .ascii
    }

  }

  /// ErrorCode:
  /// if SessionHandler::EvalCommand() returns false,
  /// return output with error_code = SESSION_FAILURE;
  enum ErrorCode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case sessionSuccess = 0
    case sessionFailure = 1

    init() {
      self = .sessionSuccess
    }

  }

  /// if launch_tool_mode is set, MozcTool is supposed to be launched
  /// by client.
  enum ToolMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// no need to launch tool
    case noTool = 0
    case configDialog = 1
    case dictionaryTool = 2
    case wordRegisterDialog = 3

    init() {
      self = .noTool
    }

  }

  /// Callback request to the client.
  struct Callback: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Callback command to be sent from the client to the server.  The
    /// optional values such as id and composition_mode can be modified
    /// or added by the client.
    var sessionCommand: Mozc_Commands_SessionCommand {
      get {_sessionCommand ?? Mozc_Commands_SessionCommand()}
      set {_sessionCommand = newValue}
    }
    /// Returns true if `sessionCommand` has been explicitly set.
    var hasSessionCommand: Bool {self._sessionCommand != nil}
    /// Clears the value of `sessionCommand`. Subsequent reads from it will return its default value.
    mutating func clearSessionCommand() {self._sessionCommand = nil}

    /// Callback command should be sent after this delay.
    var delayMillisec: UInt32 {
      get {_delayMillisec ?? 0}
      set {_delayMillisec = newValue}
    }
    /// Returns true if `delayMillisec` has been explicitly set.
    var hasDelayMillisec: Bool {self._delayMillisec != nil}
    /// Clears the value of `delayMillisec`. Subsequent reads from it will return its default value.
    mutating func clearDelayMillisec() {self._delayMillisec = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sessionCommand: Mozc_Commands_SessionCommand? = nil
    fileprivate var _delayMillisec: UInt32? = nil
  }

  struct VersionInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mozcVersion: String {
      get {_mozcVersion ?? String()}
      set {_mozcVersion = newValue}
    }
    /// Returns true if `mozcVersion` has been explicitly set.
    var hasMozcVersion: Bool {self._mozcVersion != nil}
    /// Clears the value of `mozcVersion`. Subsequent reads from it will return its default value.
    mutating func clearMozcVersion() {self._mozcVersion = nil}

    var dataVersion: String {
      get {_dataVersion ?? String()}
      set {_dataVersion = newValue}
    }
    /// Returns true if `dataVersion` has been explicitly set.
    var hasDataVersion: Bool {self._dataVersion != nil}
    /// Clears the value of `dataVersion`. Subsequent reads from it will return its default value.
    mutating func clearDataVersion() {self._dataVersion = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mozcVersion: String? = nil
    fileprivate var _dataVersion: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Mozc_Commands_Command: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: Mozc_Commands_Input {
    get {_input ?? Mozc_Commands_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var output: Mozc_Commands_Output {
    get {_output ?? Mozc_Commands_Output()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {self._output = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Mozc_Commands_Input? = nil
  fileprivate var _output: Mozc_Commands_Output? = nil
}

/// Message used by ProtoXDB as "mozc_commands".
struct Mozc_Commands_MozcCommands: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var commands: [Mozc_Commands_Command] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mozc_Commands_CommandList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This message is used for unittest.
  var commands: [Mozc_Commands_Command] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mozc.commands"

extension Mozc_Commands_CompositionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DIRECT\0\u{1}HIRAGANA\0\u{1}FULL_KATAKANA\0\u{1}HALF_ASCII\0\u{1}FULL_ASCII\0\u{1}HALF_KATAKANA\0\u{1}NUM_OF_COMPOSITIONS\0")
}

extension Mozc_Commands_KeyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_code\0\u{1}modifiers\0\u{3}special_key\0\u{3}modifier_keys\0\u{3}key_string\0\u{3}input_style\0\u{1}mode\0\u{3}probable_key_event\0\u{1}activated\0\u{3}timestamp_msec\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._keyCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._modifiers) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._specialKey) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.modifierKeys) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._keyString) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._inputStyle) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.probableKeyEvent) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._activated) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self._timestampMsec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modifiers {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._specialKey {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.modifierKeys.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.modifierKeys, fieldNumber: 4)
    }
    try { if let v = self._keyString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._inputStyle {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    if !self.probableKeyEvent.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.probableKeyEvent, fieldNumber: 8)
    }
    try { if let v = self._activated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._timestampMsec {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_KeyEvent, rhs: Mozc_Commands_KeyEvent) -> Bool {
    if lhs._keyCode != rhs._keyCode {return false}
    if lhs._modifiers != rhs._modifiers {return false}
    if lhs._specialKey != rhs._specialKey {return false}
    if lhs.modifierKeys != rhs.modifierKeys {return false}
    if lhs._keyString != rhs._keyString {return false}
    if lhs._inputStyle != rhs._inputStyle {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.probableKeyEvent != rhs.probableKeyEvent {return false}
    if lhs._activated != rhs._activated {return false}
    if lhs._timestampMsec != rhs._timestampMsec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_KeyEvent.SpecialKey: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NO_SPECIALKEY\0\u{1}DIGIT\0\u{1}ON\0\u{1}OFF\0\u{1}SPACE\0\u{1}ENTER\0\u{1}LEFT\0\u{1}RIGHT\0\u{1}UP\0\u{1}DOWN\0\u{1}ESCAPE\0\u{1}DEL\0\u{1}BACKSPACE\0\u{1}HENKAN\0\u{1}MUHENKAN\0\u{1}KANA\0\u{1}HOME\0\u{1}END\0\u{1}TAB\0\u{1}F1\0\u{1}F2\0\u{1}F3\0\u{1}F4\0\u{1}F5\0\u{1}F6\0\u{1}F7\0\u{1}F8\0\u{1}F9\0\u{1}F10\0\u{1}F11\0\u{1}F12\0\u{1}PAGE_UP\0\u{1}PAGE_DOWN\0\u{1}INSERT\0\u{1}F13\0\u{1}F14\0\u{1}F15\0\u{1}F16\0\u{1}F17\0\u{1}F18\0\u{1}F19\0\u{1}F20\0\u{1}F21\0\u{1}F22\0\u{1}F23\0\u{1}F24\0\u{1}EISU\0\u{1}NUMPAD0\0\u{1}NUMPAD1\0\u{1}NUMPAD2\0\u{1}NUMPAD3\0\u{1}NUMPAD4\0\u{1}NUMPAD5\0\u{1}NUMPAD6\0\u{1}NUMPAD7\0\u{1}NUMPAD8\0\u{1}NUMPAD9\0\u{1}MULTIPLY\0\u{1}ADD\0\u{1}SEPARATOR\0\u{1}SUBTRACT\0\u{1}DECIMAL\0\u{1}DIVIDE\0\u{1}EQUALS\0\u{1}TEXT_INPUT\0\u{1}HANKAKU\0\u{1}KANJI\0\u{1}KATAKANA\0\u{1}CAPS_LOCK\0\u{1}UNDEFINED_KEY\0\u{1}COMMA\0\u{1}CLEAR\0\u{1}VIRTUAL_LEFT\0\u{1}VIRTUAL_RIGHT\0\u{1}VIRTUAL_ENTER\0\u{1}VIRTUAL_UP\0\u{1}VIRTUAL_DOWN\0\u{1}NUM_SPECIALKEYS\0")
}

extension Mozc_Commands_KeyEvent.ModifierKey: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}CTRL\0\u{1}ALT\0\u{2}\u{2}SHIFT\0\u{2}\u{4}KEY_DOWN\0\u{2}\u{8}KEY_UP\0\u{2}\u{10}LEFT_CTRL\0\u{2} LEFT_ALT\0\u{2}@\u{1}LEFT_SHIFT\0\u{2}@\u{2}RIGHT_CTRL\0\u{2}@\u{4}RIGHT_ALT\0\u{2}@\u{8}RIGHT_SHIFT\0\u{2}@\u{10}CAPS\0")
}

extension Mozc_Commands_KeyEvent.InputStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FOLLOW_MODE\0\u{1}AS_IS\0\u{1}DIRECT_INPUT\0")
}

extension Mozc_Commands_KeyEvent.ProbableKeyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_KeyEvent.protoMessageName + ".ProbableKeyEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_code\0\u{4}\u{2}special_key\0\u{3}modifier_keys\0\u{2}\u{6}probability\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._keyCode) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._specialKey) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.modifierKeys) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self._probability) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._specialKey {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    if !self.modifierKeys.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.modifierKeys, fieldNumber: 4)
    }
    try { if let v = self._probability {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_KeyEvent.ProbableKeyEvent, rhs: Mozc_Commands_KeyEvent.ProbableKeyEvent) -> Bool {
    if lhs._keyCode != rhs._keyCode {return false}
    if lhs._specialKey != rhs._specialKey {return false}
    if lhs.modifierKeys != rhs.modifierKeys {return false}
    if lhs._probability != rhs._probability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_SessionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}id\0\u{3}composition_mode\0\u{1}text\0\u{3}cursor_position\0\u{4}\u{6}composition_events\0\u{c}\u{6}\u{1}\u{c}\u{7}\u{1}\u{c}\u{9}\u{1}\u{c}\u{8}\u{1}\u{c}\u{a}\u{1}")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._id) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._compositionMode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._cursorPosition) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.compositionEvents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._compositionMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._cursorPosition {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.compositionEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compositionEvents, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_SessionCommand, rhs: Mozc_Commands_SessionCommand) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._id != rhs._id {return false}
    if lhs._compositionMode != rhs._compositionMode {return false}
    if lhs._text != rhs._text {return false}
    if lhs._cursorPosition != rhs._cursorPosition {return false}
    if lhs.compositionEvents != rhs.compositionEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_SessionCommand.CommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}REVERT\0\u{1}SUBMIT\0\u{1}SELECT_CANDIDATE\0\u{1}HIGHLIGHT_CANDIDATE\0\u{1}SWITCH_COMPOSITION_MODE\0\u{1}GET_STATUS\0\u{1}SUBMIT_CANDIDATE\0\u{1}CONVERT_REVERSE\0\u{1}UNDO\0\u{1}RESET_CONTEXT\0\u{1}MOVE_CURSOR\0\u{1}SWITCH_INPUT_FIELD_TYPE\0\u{2}\u{2}UNDO_OR_REWIND\0\u{2}\u{5}COMMIT_RAW_TEXT\0\u{1}CONVERT_PREV_PAGE\0\u{1}CONVERT_NEXT_PAGE\0\u{1}TURN_ON_IME\0\u{1}TURN_OFF_IME\0\u{1}DELETE_CANDIDATE_FROM_HISTORY\0\u{1}STOP_KEY_TOGGLING\0\u{1}UPDATE_COMPOSITION\0\u{1}REQUEST_NWP\0")
}

extension Mozc_Commands_SessionCommand.CompositionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_SessionCommand.protoMessageName + ".CompositionEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}composition_string\0\u{1}probability\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._compositionString) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._probability) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._compositionString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._probability {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_SessionCommand.CompositionEvent, rhs: Mozc_Commands_SessionCommand.CompositionEvent) -> Bool {
    if lhs._compositionString != rhs._compositionString {return false}
    if lhs._probability != rhs._probability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Context: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Context"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}preceding_text\0\u{3}following_text\0\u{3}suppress_suggestion\0\u{3}input_field_type\0\u{1}revision\0\u{4}_\u{1}experimental_features\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._precedingText) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._followingText) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._suppressSuggestion) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._inputFieldType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._revision) }()
      case 100: try { try decoder.decodeRepeatedStringField(value: &self.experimentalFeatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._precedingText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._followingText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._suppressSuggestion {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._inputFieldType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._revision {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    if !self.experimentalFeatures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.experimentalFeatures, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Context, rhs: Mozc_Commands_Context) -> Bool {
    if lhs._precedingText != rhs._precedingText {return false}
    if lhs._followingText != rhs._followingText {return false}
    if lhs._suppressSuggestion != rhs._suppressSuggestion {return false}
    if lhs._inputFieldType != rhs._inputFieldType {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs.experimentalFeatures != rhs.experimentalFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Context.InputFieldType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}NORMAL\0\u{1}PASSWORD\0\u{1}TEL\0\u{1}NUMBER\0")
}

extension Mozc_Commands_Capability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capability"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}text_deletion\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._textDeletion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._textDeletion {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Capability, rhs: Mozc_Commands_Capability) -> Bool {
    if lhs._textDeletion != rhs._textDeletion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Capability.TextDeletionCapabilityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NO_TEXT_DELETION_CAPABILITY\0\u{1}DELETE_PRECEDING_TEXT\0")
}

extension Mozc_Commands_DecoderExperimentParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecoderExperimentParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{8}variation_character_types\0\u{4}\u{1c}disable_zero_query_suffix_prediction\0\u{4}\u{13}english_variation_space_insertion_mode\0\u{4}\u{8}candidate_consistency_cost_max_diff\0\u{3}max_composition_event_to_process\0\u{4}\u{12}user_history_prediction_max_char_coverage\0\u{3}katakana_promotion_offset\0\u{4}\u{2}typing_correction_apply_user_history_size\0\u{4}\u{a}typing_correction_result_reranker_mode\0\u{4}\u{5}typing_correction_result_reranker_interpolation_weight\0\u{3}typing_correction_result_reranker_literal_on_top_weight\0\u{3}handwriting_conversion_candidate_cost_offset\0\u{4}\u{5}suffix_nwp_transition_cost_threshold\0\u{4}\u{19}symbol_rewriter_candidate_position\0\u{3}symbol_rewriter_promotion_size\0\u{4}\u{2}user_history_cache_inner_segment_boundary\0\u{c}\u{1}\u{1}")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._variationCharacterTypes) }()
      case 36: try { try decoder.decodeSingularBoolField(value: &self._disableZeroQuerySuffixPrediction) }()
      case 55: try { try decoder.decodeSingularInt32Field(value: &self._englishVariationSpaceInsertionMode) }()
      case 63: try { try decoder.decodeSingularInt32Field(value: &self._candidateConsistencyCostMaxDiff) }()
      case 64: try { try decoder.decodeSingularInt32Field(value: &self._maxCompositionEventToProcess) }()
      case 82: try { try decoder.decodeSingularInt32Field(value: &self._userHistoryPredictionMaxCharCoverage) }()
      case 83: try { try decoder.decodeSingularInt32Field(value: &self._katakanaPromotionOffset) }()
      case 85: try { try decoder.decodeSingularInt32Field(value: &self._typingCorrectionApplyUserHistorySize) }()
      case 95: try { try decoder.decodeSingularInt32Field(value: &self._typingCorrectionResultRerankerMode) }()
      case 100: try { try decoder.decodeSingularFloatField(value: &self._typingCorrectionResultRerankerInterpolationWeight) }()
      case 101: try { try decoder.decodeSingularFloatField(value: &self._typingCorrectionResultRerankerLiteralOnTopWeight) }()
      case 102: try { try decoder.decodeSingularInt32Field(value: &self._handwritingConversionCandidateCostOffset) }()
      case 107: try { try decoder.decodeSingularInt32Field(value: &self._suffixNwpTransitionCostThreshold) }()
      case 132: try { try decoder.decodeSingularInt32Field(value: &self._symbolRewriterCandidatePosition) }()
      case 133: try { try decoder.decodeSingularInt32Field(value: &self._symbolRewriterPromotionSize) }()
      case 135: try { try decoder.decodeSingularBoolField(value: &self._userHistoryCacheInnerSegmentBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._variationCharacterTypes {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._disableZeroQuerySuffixPrediction {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 36)
    } }()
    try { if let v = self._englishVariationSpaceInsertionMode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 55)
    } }()
    try { if let v = self._candidateConsistencyCostMaxDiff {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 63)
    } }()
    try { if let v = self._maxCompositionEventToProcess {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 64)
    } }()
    try { if let v = self._userHistoryPredictionMaxCharCoverage {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 82)
    } }()
    try { if let v = self._katakanaPromotionOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 83)
    } }()
    try { if let v = self._typingCorrectionApplyUserHistorySize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 85)
    } }()
    try { if let v = self._typingCorrectionResultRerankerMode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 95)
    } }()
    try { if let v = self._typingCorrectionResultRerankerInterpolationWeight {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 100)
    } }()
    try { if let v = self._typingCorrectionResultRerankerLiteralOnTopWeight {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 101)
    } }()
    try { if let v = self._handwritingConversionCandidateCostOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 102)
    } }()
    try { if let v = self._suffixNwpTransitionCostThreshold {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 107)
    } }()
    try { if let v = self._symbolRewriterCandidatePosition {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 132)
    } }()
    try { if let v = self._symbolRewriterPromotionSize {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 133)
    } }()
    try { if let v = self._userHistoryCacheInnerSegmentBoundary {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 135)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_DecoderExperimentParams, rhs: Mozc_Commands_DecoderExperimentParams) -> Bool {
    if lhs._variationCharacterTypes != rhs._variationCharacterTypes {return false}
    if lhs._typingCorrectionResultRerankerMode != rhs._typingCorrectionResultRerankerMode {return false}
    if lhs._typingCorrectionResultRerankerInterpolationWeight != rhs._typingCorrectionResultRerankerInterpolationWeight {return false}
    if lhs._typingCorrectionResultRerankerLiteralOnTopWeight != rhs._typingCorrectionResultRerankerLiteralOnTopWeight {return false}
    if lhs._typingCorrectionApplyUserHistorySize != rhs._typingCorrectionApplyUserHistorySize {return false}
    if lhs._disableZeroQuerySuffixPrediction != rhs._disableZeroQuerySuffixPrediction {return false}
    if lhs._userHistoryPredictionMaxCharCoverage != rhs._userHistoryPredictionMaxCharCoverage {return false}
    if lhs._englishVariationSpaceInsertionMode != rhs._englishVariationSpaceInsertionMode {return false}
    if lhs._candidateConsistencyCostMaxDiff != rhs._candidateConsistencyCostMaxDiff {return false}
    if lhs._maxCompositionEventToProcess != rhs._maxCompositionEventToProcess {return false}
    if lhs._katakanaPromotionOffset != rhs._katakanaPromotionOffset {return false}
    if lhs._handwritingConversionCandidateCostOffset != rhs._handwritingConversionCandidateCostOffset {return false}
    if lhs._suffixNwpTransitionCostThreshold != rhs._suffixNwpTransitionCostThreshold {return false}
    if lhs._userHistoryCacheInnerSegmentBoundary != rhs._userHistoryCacheInnerSegmentBoundary {return false}
    if lhs._symbolRewriterCandidatePosition != rhs._symbolRewriterCandidatePosition {return false}
    if lhs._symbolRewriterPromotionSize != rhs._symbolRewriterPromotionSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_DecoderExperimentParams.VariationCharacterType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NO_VARIATION\0\u{1}SVS_JAPANESE\0")
}

extension Mozc_Commands_DecoderExperimentParams.BigramNwpFilteringMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT\0\u{1}FILTER_SAME_CTYPE\0\u{1}FILTER_ALL\0")
}

extension Mozc_Commands_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}zero_query_suggestion\0\u{3}mixed_conversion\0\u{4}\u{2}special_romanji_table\0\u{4}\u{2}space_on_alphanumeric\0\u{3}keyboard_name\0\u{3}update_input_mode_from_surrounding_text\0\u{3}kana_modifier_insensitive_conversion\0\u{3}auto_partial_suggestion\0\u{4}\u{2}emoji_rewriter_capability\0\u{3}crossing_edge_behavior\0\u{3}language_aware_input\0\u{3}candidate_page_size\0\u{3}candidates_size_limit\0\u{3}decoder_experiment_params\0\u{3}fill_incognito_candidate_words\0\u{4}\u{2}enable_a11y_description\0\u{3}additional_renderable_character_groups\0\u{3}is_handwriting\0\u{3}is_incognito_mode\0\u{3}display_value_capability\0\u{c}\u{3}\u{1}\u{c}\u{b}\u{1}\u{c}\u{13}\u{1}")

  fileprivate class _StorageClass {
    var _zeroQuerySuggestion: Bool? = nil
    var _mixedConversion: Bool? = nil
    var _specialRomanjiTable: Mozc_Commands_Request.SpecialRomanjiTable? = nil
    var _spaceOnAlphanumeric: Mozc_Commands_Request.SpaceOnAlphanumeric? = nil
    var _keyboardName: String? = nil
    var _updateInputModeFromSurroundingText: Bool? = nil
    var _kanaModifierInsensitiveConversion: Bool? = nil
    var _autoPartialSuggestion: Bool? = nil
    var _emojiRewriterCapability: Int32? = nil
    var _crossingEdgeBehavior: Mozc_Commands_Request.CrossingEdgeBehavior? = nil
    var _languageAwareInput: Mozc_Commands_Request.LanguageAwareInputBehavior? = nil
    var _candidatePageSize: Int32? = nil
    var _candidatesSizeLimit: Int32? = nil
    var _decoderExperimentParams: Mozc_Commands_DecoderExperimentParams? = nil
    var _fillIncognitoCandidateWords: Bool? = nil
    var _enableA11YDescription: Bool? = nil
    var _additionalRenderableCharacterGroups: [Mozc_Commands_Request.AdditionalRenderableCharacterGroup] = []
    var _isHandwriting: Bool? = nil
    var _isIncognitoMode: Bool? = nil
    var _displayValueCapability: Mozc_Commands_Request.DisplayValueCapability? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _zeroQuerySuggestion = source._zeroQuerySuggestion
      _mixedConversion = source._mixedConversion
      _specialRomanjiTable = source._specialRomanjiTable
      _spaceOnAlphanumeric = source._spaceOnAlphanumeric
      _keyboardName = source._keyboardName
      _updateInputModeFromSurroundingText = source._updateInputModeFromSurroundingText
      _kanaModifierInsensitiveConversion = source._kanaModifierInsensitiveConversion
      _autoPartialSuggestion = source._autoPartialSuggestion
      _emojiRewriterCapability = source._emojiRewriterCapability
      _crossingEdgeBehavior = source._crossingEdgeBehavior
      _languageAwareInput = source._languageAwareInput
      _candidatePageSize = source._candidatePageSize
      _candidatesSizeLimit = source._candidatesSizeLimit
      _decoderExperimentParams = source._decoderExperimentParams
      _fillIncognitoCandidateWords = source._fillIncognitoCandidateWords
      _enableA11YDescription = source._enableA11YDescription
      _additionalRenderableCharacterGroups = source._additionalRenderableCharacterGroups
      _isHandwriting = source._isHandwriting
      _isIncognitoMode = source._isIncognitoMode
      _displayValueCapability = source._displayValueCapability
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._zeroQuerySuggestion) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._mixedConversion) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._specialRomanjiTable) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._spaceOnAlphanumeric) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._keyboardName) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._updateInputModeFromSurroundingText) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._kanaModifierInsensitiveConversion) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._autoPartialSuggestion) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._emojiRewriterCapability) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._crossingEdgeBehavior) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._languageAwareInput) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._candidatePageSize) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._candidatesSizeLimit) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._decoderExperimentParams) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._fillIncognitoCandidateWords) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._enableA11YDescription) }()
        case 21: try { try decoder.decodeRepeatedEnumField(value: &_storage._additionalRenderableCharacterGroups) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._isHandwriting) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._isIncognitoMode) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._displayValueCapability) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._zeroQuerySuggestion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._mixedConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._specialRomanjiTable {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spaceOnAlphanumeric {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._keyboardName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._updateInputModeFromSurroundingText {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._kanaModifierInsensitiveConversion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._autoPartialSuggestion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._emojiRewriterCapability {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._crossingEdgeBehavior {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._languageAwareInput {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._candidatePageSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._candidatesSizeLimit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._decoderExperimentParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._fillIncognitoCandidateWords {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._enableA11YDescription {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      if !_storage._additionalRenderableCharacterGroups.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._additionalRenderableCharacterGroups, fieldNumber: 21)
      }
      try { if let v = _storage._isHandwriting {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._isIncognitoMode {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._displayValueCapability {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Request, rhs: Mozc_Commands_Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._zeroQuerySuggestion != rhs_storage._zeroQuerySuggestion {return false}
        if _storage._mixedConversion != rhs_storage._mixedConversion {return false}
        if _storage._specialRomanjiTable != rhs_storage._specialRomanjiTable {return false}
        if _storage._spaceOnAlphanumeric != rhs_storage._spaceOnAlphanumeric {return false}
        if _storage._keyboardName != rhs_storage._keyboardName {return false}
        if _storage._updateInputModeFromSurroundingText != rhs_storage._updateInputModeFromSurroundingText {return false}
        if _storage._kanaModifierInsensitiveConversion != rhs_storage._kanaModifierInsensitiveConversion {return false}
        if _storage._autoPartialSuggestion != rhs_storage._autoPartialSuggestion {return false}
        if _storage._emojiRewriterCapability != rhs_storage._emojiRewriterCapability {return false}
        if _storage._crossingEdgeBehavior != rhs_storage._crossingEdgeBehavior {return false}
        if _storage._languageAwareInput != rhs_storage._languageAwareInput {return false}
        if _storage._candidatePageSize != rhs_storage._candidatePageSize {return false}
        if _storage._candidatesSizeLimit != rhs_storage._candidatesSizeLimit {return false}
        if _storage._decoderExperimentParams != rhs_storage._decoderExperimentParams {return false}
        if _storage._fillIncognitoCandidateWords != rhs_storage._fillIncognitoCandidateWords {return false}
        if _storage._enableA11YDescription != rhs_storage._enableA11YDescription {return false}
        if _storage._additionalRenderableCharacterGroups != rhs_storage._additionalRenderableCharacterGroups {return false}
        if _storage._isHandwriting != rhs_storage._isHandwriting {return false}
        if _storage._isIncognitoMode != rhs_storage._isIncognitoMode {return false}
        if _storage._displayValueCapability != rhs_storage._displayValueCapability {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Request.SpecialRomanjiTable: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT_TABLE\0\u{2}\u{a}TWELVE_KEYS_TO_HIRAGANA\0\u{1}TWELVE_KEYS_TO_HALFWIDTHASCII\0\u{2}\u{2}FLICK_TO_HIRAGANA\0\u{1}FLICK_TO_HALFWIDTHASCII\0\u{2}\u{2}TOGGLE_FLICK_TO_HIRAGANA\0\u{1}TOGGLE_FLICK_TO_HALFWIDTHASCII\0\u{2}\u{3}QWERTY_MOBILE_TO_HIRAGANA\0\u{2}\u{2}QWERTY_MOBILE_TO_HALFWIDTHASCII\0\u{2}\u{8}GODAN_TO_HIRAGANA\0\u{1}GODAN_TO_HALFWIDTHASCII\0\u{2}\u{9}NOTOUCH_TO_HIRAGANA\0\u{1}NOTOUCH_TO_HALFWIDTHASCII\0\u{1}TOGGLE_FLICK_TO_NUMBER\0\u{1}FLICK_TO_NUMBER\0\u{1}FLICK_TO_HALFWIDTHASCII_IOS\0\u{1}TOGGLE_FLICK_TO_HALFWIDTHASCII_IOS\0\u{1}FIFTY_KEYS_TO_HIRAGANA\0\u{2}b[\u{2}TWELVE_KEYS_TO_HIRAGANA_INTUITIVE\0\u{1}TOGGLE_FLICK_TO_HIRAGANA_INTUITIVE\0\u{1}FLICK_TO_HIRAGANA_INTUITIVE\0")
}

extension Mozc_Commands_Request.SpaceOnAlphanumeric: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SPACE_OR_CONVERT_KEEPING_COMPOSITION\0\u{1}SPACE_OR_CONVERT_COMMITTING_COMPOSITION\0\u{1}COMMIT\0")
}

extension Mozc_Commands_Request.RewriterCapability: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOT_AVAILABLE\0\u{1}CONVERSION\0\u{1}PREDICTION\0\u{2}\u{2}SUGGESTION\0\u{2}\u{3}ALL\0")
}

extension Mozc_Commands_Request.CrossingEdgeBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DO_NOTHING\0\u{1}COMMIT_WITHOUT_CONSUMING\0")
}

extension Mozc_Commands_Request.LanguageAwareInputBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEFAULT_LANGUAGE_AWARE_BEHAVIOR\0\u{1}NO_LANGUAGE_AWARE_INPUT\0\u{1}LANGUAGE_AWARE_SUGGESTION\0")
}

extension Mozc_Commands_Request.AdditionalRenderableCharacterGroup: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0EMPTY\0\u{2}\u{2}KANA_SUPPLEMENT_6_0\0\u{1}KANA_SUPPLEMENT_AND_KANA_EXTENDED_A_10_0\0\u{1}KANA_EXTENDED_A_14_0\0\u{1}EMOJI_12_1\0\u{1}EMOJI_13_0\0\u{1}EMOJI_13_1\0\u{1}EMOJI_14_0\0\u{1}EMOJI_15_0\0\u{1}EGYPTIAN_HIEROGLYPH_5_2\0\u{1}IVS_CHARACTER\0\u{1}EMOJI_15_1\0\u{1}EMOJI_16_0\0\u{1}EMOJI_17_0\0")
}

extension Mozc_Commands_Request.DisplayValueCapability: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOT_SUPPORTED\0\u{1}PLAIN_TEXT\0")
}

extension Mozc_Commands_ApplicationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplicationInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}process_id\0\u{3}thread_id\0\u{c}\u{3}\u{1}")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._processID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._threadID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._processID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._threadID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_ApplicationInfo, rhs: Mozc_Commands_ApplicationInfo) -> Bool {
    if lhs._processID != rhs._processID {return false}
    if lhs._threadID != rhs._threadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Input"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}id\0\u{1}key\0\u{1}command\0\u{1}config\0\u{1}context\0\u{1}capability\0\u{3}application_info\0\u{1}request\0\u{4}\u{3}touch_events\0\u{4}\u{2}request_suggestion\0\u{3}engine_reload_request\0\u{4}\u{2}user_dictionary_import_data\0\u{c}\u{a}\u{1}\u{c}\u{b}\u{1}\u{c}\u{d}\u{1}\u{c}\u{10}\u{1}")

  fileprivate class _StorageClass {
    var _type: Mozc_Commands_Input.CommandType? = nil
    var _id: UInt64? = nil
    var _key: Mozc_Commands_KeyEvent? = nil
    var _command: Mozc_Commands_SessionCommand? = nil
    var _config: Mozc_Config_Config? = nil
    var _context: Mozc_Commands_Context? = nil
    var _capability: Mozc_Commands_Capability? = nil
    var _applicationInfo: Mozc_Commands_ApplicationInfo? = nil
    var _request: Mozc_Commands_Request? = nil
    var _touchEvents: [Mozc_Commands_Input.TouchEvent] = []
    var _userDictionaryImportData: Mozc_UserDictionary_UserDictionaryImportData? = nil
    var _requestSuggestion: Bool? = nil
    var _engineReloadRequest: Mozc_EngineReloadRequest? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _id = source._id
      _key = source._key
      _command = source._command
      _config = source._config
      _context = source._context
      _capability = source._capability
      _applicationInfo = source._applicationInfo
      _request = source._request
      _touchEvents = source._touchEvents
      _userDictionaryImportData = source._userDictionaryImportData
      _requestSuggestion = source._requestSuggestion
      _engineReloadRequest = source._engineReloadRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._command, !v.isInitialized {return false}
      if let v = _storage._engineReloadRequest, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._command) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._context) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._capability) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._applicationInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._touchEvents) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._requestSuggestion) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._engineReloadRequest) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._userDictionaryImportData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._id {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._command {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._context {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._capability {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._applicationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._touchEvents.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._touchEvents, fieldNumber: 12)
      }
      try { if let v = _storage._requestSuggestion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._engineReloadRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._userDictionaryImportData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Input, rhs: Mozc_Commands_Input) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._capability != rhs_storage._capability {return false}
        if _storage._applicationInfo != rhs_storage._applicationInfo {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._touchEvents != rhs_storage._touchEvents {return false}
        if _storage._userDictionaryImportData != rhs_storage._userDictionaryImportData {return false}
        if _storage._requestSuggestion != rhs_storage._requestSuggestion {return false}
        if _storage._engineReloadRequest != rhs_storage._engineReloadRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Input.CommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}CREATE_SESSION\0\u{1}DELETE_SESSION\0\u{1}SEND_KEY\0\u{1}TEST_SEND_KEY\0\u{1}SEND_COMMAND\0\u{1}GET_CONFIG\0\u{1}SET_CONFIG\0\u{1}SYNC_DATA\0\u{1}SHUTDOWN\0\u{1}RELOAD\0\u{1}CLEAR_USER_HISTORY\0\u{1}CLEAR_USER_PREDICTION\0\u{1}CLEANUP\0\u{1}NO_OPERATION\0\u{1}RELOAD_AND_WAIT\0\u{1}CLEAR_UNUSED_USER_PREDICTION\0\u{1}SET_REQUEST\0\u{2}\u{2}GET_SERVER_VERSION\0\u{2}\u{8}SEND_ENGINE_RELOAD_REQUEST\0\u{2}\u{3}RELOAD_SUPPLEMENTAL_MODEL\0\u{1}IMPORT_USER_DICTIONARY\0\u{1}NUM_OF_COMMANDS\0")
}

extension Mozc_Commands_Input.TouchAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}TOUCH_DOWN\0\u{1}TOUCH_MOVE\0\u{1}TOUCH_UP\0")
}

extension Mozc_Commands_Input.TouchPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_Input.protoMessageName + ".TouchPosition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}action\0\u{1}x\0\u{1}y\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._x) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._y) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._x {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._y {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Input.TouchPosition, rhs: Mozc_Commands_Input.TouchPosition) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Input.TouchEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_Input.protoMessageName + ".TouchEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_id\0\u{1}stroke\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._sourceID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stroke) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sourceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.stroke.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stroke, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Input.TouchEvent, rhs: Mozc_Commands_Input.TouchEvent) -> Bool {
    if lhs._sourceID != rhs._sourceID {return false}
    if lhs.stroke != rhs.stroke {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_ResultToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResultToken"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}key\0\u{1}lid\0\u{1}rid\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._lid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._rid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_ResultToken, rhs: Mozc_Commands_ResultToken) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._key != rhs._key {return false}
    if lhs._lid != rhs._lid {return false}
    if lhs._rid != rhs._rid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Result"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}value\0\u{1}key\0\u{3}cursor_offset\0\u{1}tokens\0")

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._value == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._cursorOffset) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cursorOffset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Result, rhs: Mozc_Commands_Result) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._value != rhs._value {return false}
    if lhs._key != rhs._key {return false}
    if lhs._cursorOffset != rhs._cursorOffset {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Result.ResultType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}STRING\0")
}

extension Mozc_Commands_Preedit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Preedit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cursor\0\u{7}Segment\0\u{3}highlighted_position\0\u{3}is_toggleable\0")

  public var isInitialized: Bool {
    if self._cursor == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.segment) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._cursor) }()
      case 2: try { try decoder.decodeRepeatedGroupField(value: &self.segment) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._highlightedPosition) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isToggleable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cursor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.segment.isEmpty {
      try visitor.visitRepeatedGroupField(value: self.segment, fieldNumber: 2)
    }
    try { if let v = self._highlightedPosition {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isToggleable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Preedit, rhs: Mozc_Commands_Preedit) -> Bool {
    if lhs._cursor != rhs._cursor {return false}
    if lhs.segment != rhs.segment {return false}
    if lhs._highlightedPosition != rhs._highlightedPosition {return false}
    if lhs._isToggleable != rhs._isToggleable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Preedit.Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_Preedit.protoMessageName + ".Segment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}annotation\0\u{1}value\0\u{3}value_length\0\u{1}key\0")

  public var isInitialized: Bool {
    if self._annotation == nil {return false}
    if self._value == nil {return false}
    if self._valueLength == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularEnumField(value: &self._annotation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._valueLength) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._annotation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._valueLength {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Preedit.Segment, rhs: Mozc_Commands_Preedit.Segment) -> Bool {
    if lhs._annotation != rhs._annotation {return false}
    if lhs._value != rhs._value {return false}
    if lhs._valueLength != rhs._valueLength {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Preedit.Segment.Annotation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}UNDERLINE\0\u{1}HIGHLIGHT\0")
}

extension Mozc_Commands_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}activated\0\u{1}mode\0\u{3}comeback_mode\0\u{4}\u{17}undo_available\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._activated) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._comebackMode) }()
      case 26: try { try decoder.decodeSingularBoolField(value: &self._undoAvailable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._comebackMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._undoAvailable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Status, rhs: Mozc_Commands_Status) -> Bool {
    if lhs._activated != rhs._activated {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs._comebackMode != rhs._comebackMode {return false}
    if lhs._undoAvailable != rhs._undoAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_DeletionRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeletionRange"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}offset\0\u{1}length\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._offset) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offset {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_DeletionRange, rhs: Mozc_Commands_DeletionRange) -> Bool {
    if lhs._offset != rhs._offset {return false}
    if lhs._length != rhs._length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Output"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}mode\0\u{1}consumed\0\u{1}result\0\u{1}preedit\0\u{3}candidate_window\0\u{1}key\0\u{1}url\0\u{1}config\0\u{3}preedit_method\0\u{3}error_code\0\u{2}\u{2}status\0\u{3}all_candidate_words\0\u{4}\u{2}deletion_range\0\u{3}launch_tool_mode\0\u{1}callback\0\u{4}\u{4}engine_reload_response\0\u{3}removed_candidate_words_for_debug\0\u{4}\u{2}incognito_candidate_words\0\u{3}server_version\0\u{c}\u{c}\u{1}\u{c}\u{f}\u{1}\u{c}\u{13}\u{1}\u{c}\u{14}\u{1}\u{c}\u{15}\u{1}\u{c}\u{18}\u{1}")

  fileprivate class _StorageClass {
    var _id: UInt64? = nil
    var _mode: Mozc_Commands_CompositionMode? = nil
    var _consumed: Bool? = nil
    var _result: Mozc_Commands_Result? = nil
    var _preedit: Mozc_Commands_Preedit? = nil
    var _candidateWindow: Mozc_Commands_CandidateWindow? = nil
    var _key: Mozc_Commands_KeyEvent? = nil
    var _url: String? = nil
    var _config: Mozc_Config_Config? = nil
    var _preeditMethod: Mozc_Commands_Output.PreeditMethod? = nil
    var _errorCode: Mozc_Commands_Output.ErrorCode? = nil
    var _status: Mozc_Commands_Status? = nil
    var _allCandidateWords: Mozc_Commands_CandidateList? = nil
    var _deletionRange: Mozc_Commands_DeletionRange? = nil
    var _launchToolMode: Mozc_Commands_Output.ToolMode? = nil
    var _callback: Mozc_Commands_Output.Callback? = nil
    var _engineReloadResponse: Mozc_EngineReloadResponse? = nil
    var _removedCandidateWordsForDebug: Mozc_Commands_CandidateList? = nil
    var _incognitoCandidateWords: Mozc_Commands_CandidateList? = nil
    var _serverVersion: Mozc_Commands_Output.VersionInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _mode = source._mode
      _consumed = source._consumed
      _result = source._result
      _preedit = source._preedit
      _candidateWindow = source._candidateWindow
      _key = source._key
      _url = source._url
      _config = source._config
      _preeditMethod = source._preeditMethod
      _errorCode = source._errorCode
      _status = source._status
      _allCandidateWords = source._allCandidateWords
      _deletionRange = source._deletionRange
      _launchToolMode = source._launchToolMode
      _callback = source._callback
      _engineReloadResponse = source._engineReloadResponse
      _removedCandidateWordsForDebug = source._removedCandidateWordsForDebug
      _incognitoCandidateWords = source._incognitoCandidateWords
      _serverVersion = source._serverVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._result, !v.isInitialized {return false}
      if let v = _storage._preedit, !v.isInitialized {return false}
      if let v = _storage._candidateWindow, !v.isInitialized {return false}
      if let v = _storage._callback, !v.isInitialized {return false}
      if let v = _storage._engineReloadResponse, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._mode) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._consumed) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._preedit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._candidateWindow) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._key) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._preeditMethod) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._errorCode) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._allCandidateWords) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._deletionRange) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._launchToolMode) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._callback) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._engineReloadResponse) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._removedCandidateWordsForDebug) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._incognitoCandidateWords) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._serverVersion) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._mode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._consumed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._preedit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._candidateWindow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._preeditMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._errorCode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._allCandidateWords {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._deletionRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._launchToolMode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._callback {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._engineReloadResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._removedCandidateWordsForDebug {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._incognitoCandidateWords {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._serverVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Output, rhs: Mozc_Commands_Output) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._consumed != rhs_storage._consumed {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._preedit != rhs_storage._preedit {return false}
        if _storage._candidateWindow != rhs_storage._candidateWindow {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._preeditMethod != rhs_storage._preeditMethod {return false}
        if _storage._errorCode != rhs_storage._errorCode {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._allCandidateWords != rhs_storage._allCandidateWords {return false}
        if _storage._deletionRange != rhs_storage._deletionRange {return false}
        if _storage._launchToolMode != rhs_storage._launchToolMode {return false}
        if _storage._callback != rhs_storage._callback {return false}
        if _storage._engineReloadResponse != rhs_storage._engineReloadResponse {return false}
        if _storage._removedCandidateWordsForDebug != rhs_storage._removedCandidateWordsForDebug {return false}
        if _storage._incognitoCandidateWords != rhs_storage._incognitoCandidateWords {return false}
        if _storage._serverVersion != rhs_storage._serverVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Output.PreeditMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ASCII\0\u{1}KANA\0")
}

extension Mozc_Commands_Output.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SESSION_SUCCESS\0\u{1}SESSION_FAILURE\0")
}

extension Mozc_Commands_Output.ToolMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NO_TOOL\0\u{1}CONFIG_DIALOG\0\u{1}DICTIONARY_TOOL\0\u{1}WORD_REGISTER_DIALOG\0")
}

extension Mozc_Commands_Output.Callback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_Output.protoMessageName + ".Callback"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_command\0\u{3}delay_millisec\0")

  public var isInitialized: Bool {
    if let v = self._sessionCommand, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sessionCommand) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._delayMillisec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionCommand {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delayMillisec {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Output.Callback, rhs: Mozc_Commands_Output.Callback) -> Bool {
    if lhs._sessionCommand != rhs._sessionCommand {return false}
    if lhs._delayMillisec != rhs._delayMillisec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Output.VersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Mozc_Commands_Output.protoMessageName + ".VersionInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}mozc_version\0\u{3}data_version\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mozcVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._dataVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mozcVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Output.VersionInfo, rhs: Mozc_Commands_Output.VersionInfo) -> Bool {
    if lhs._mozcVersion != rhs._mozcVersion {return false}
    if lhs._dataVersion != rhs._dataVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0\u{1}output\0")

  public var isInitialized: Bool {
    if self._input == nil {return false}
    if let v = self._input, !v.isInitialized {return false}
    if let v = self._output, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_Command, rhs: Mozc_Commands_Command) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._output != rhs._output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_MozcCommands: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MozcCommands"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}commands\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.commands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.commands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_MozcCommands, rhs: Mozc_Commands_MozcCommands) -> Bool {
    if lhs.commands != rhs.commands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mozc_Commands_CommandList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}commands\0")

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.commands) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.commands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mozc_Commands_CommandList, rhs: Mozc_Commands_CommandList) -> Bool {
    if lhs.commands != rhs.commands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
